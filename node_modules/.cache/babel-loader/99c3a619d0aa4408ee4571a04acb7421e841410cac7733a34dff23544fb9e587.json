{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as st, RELAYER_EVENTS as Pe, VERIFY_SERVER as it, EXPIRER_EVENTS as rt, PAIRING_EVENTS as ve, Store as U, Core as nt } from \"@walletconnect/core\";\nimport { pino as ot, getDefaultLoggerOptions as at, generateChildLogger as ct, getLoggerContext as lt } from \"@walletconnect/logger\";\nimport { IEngine as ht, ISignClient as pt } from \"@walletconnect/types\";\nimport { getInternalError as l, calcExpiry as N, createDelayedPromise as G, engineEvent as g, getSdkError as I, getDeepLink as dt, handleDeeplinkRedirect as ut, isSessionCompatible as gt, hashKey as ue, parseChainId as ge, createEncodedRecap as wt, getRecapFromResources as we, mergeEncodedRecaps as mt, validateSignedCacao as Oe, getNamespacedDidChainId as Te, getDidAddress as Ae, getMethodsFromRecap as xe, getChainsFromRecap as De, buildNamespacesFromAuth as Ve, formatMessage as yt, isBrowser as Rt, hashMessage as te, isExpired as k, MemoryStore as Y, isValidParams as x, isUndefined as X, isValidRelays as Et, isValidObject as Ce, isValidRequiredNamespaces as St, isValidNamespaces as me, isConformingNamespaces as be, isValidString as V, isValidErrorReason as _t, isValidRelay as ft, isValidController as It, isValidNamespacesChainId as $e, isValidRequest as qt, isValidNamespacesRequest as Nt, isValidRequestExpiry as Pt, isValidResponse as vt, isValidEvent as Ot, isValidNamespacesEvent as Tt, parseExpirerTarget as At, isValidId as xt, TYPE_1 as ye, getAppMetadata as Dt } from \"@walletconnect/utils\";\nimport Vt, { EventEmitter as Ct } from \"events\";\nimport { THIRTY_DAYS as bt, SEVEN_DAYS as Le, FIVE_MINUTES as q, ONE_DAY as C, ONE_HOUR as Me, ONE_SECOND as $t, toMiliseconds as Ke } from \"@walletconnect/time\";\nimport { payloadId as j, getBigIntRpcId as se, isJsonRpcResult as b, isJsonRpcError as $, formatJsonRpcRequest as Re, formatJsonRpcResult as Lt, formatJsonRpcError as Mt, isJsonRpcRequest as Kt, isJsonRpcResponse as Ut } from \"@walletconnect/jsonrpc-utils\";\nconst Ee = \"wc\",\n  Se = 2,\n  _e = \"client\",\n  ie = `${Ee}@${Se}:${_e}:`,\n  re = {\n    name: _e,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Gt = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\",\n    session_authenticate: \"session_authenticate\",\n    session_request_expire: \"session_request_expire\"\n  },\n  kt = {\n    database: \":memory:\"\n  },\n  fe = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  jt = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Ft = \"history\",\n  Qt = \"0.3\",\n  Ue = \"proposal\",\n  zt = bt,\n  Ge = \"Proposal expired\",\n  ke = \"session\",\n  L = Le,\n  je = \"engine\",\n  R = {\n    wc_sessionPropose: {\n      req: {\n        ttl: q,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1101\n      },\n      reject: {\n        ttl: q,\n        prompt: !1,\n        tag: 1120\n      },\n      autoReject: {\n        ttl: q,\n        prompt: !1,\n        tag: 1121\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: C,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: C,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: q,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: q,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: C,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: C,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: C,\n        prompt: !1,\n        tag: 1115\n      }\n    },\n    wc_sessionAuthenticate: {\n      req: {\n        ttl: Me,\n        prompt: !0,\n        tag: 1116\n      },\n      res: {\n        ttl: Me,\n        prompt: !1,\n        tag: 1117\n      },\n      reject: {\n        ttl: q,\n        prompt: !1,\n        tag: 1118\n      },\n      autoReject: {\n        ttl: q,\n        prompt: !1,\n        tag: 1119\n      }\n    }\n  },\n  ne = {\n    min: q,\n    max: Le\n  },\n  D = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  Fe = \"request\",\n  Qe = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"],\n  ze = \"wc\",\n  Ht = 1.5,\n  He = \"auth\",\n  Ye = \"authKeys\",\n  Xe = \"pairingTopics\",\n  Je = \"requests\",\n  J = `${ze}@${1.5}:${He}:`,\n  B = `${J}:PUB_KEY`;\nvar Yt = Object.defineProperty,\n  Xt = Object.defineProperties,\n  Jt = Object.getOwnPropertyDescriptors,\n  Be = Object.getOwnPropertySymbols,\n  Bt = Object.prototype.hasOwnProperty,\n  Wt = Object.prototype.propertyIsEnumerable,\n  We = (E, n, t) => n in E ? Yt(E, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : E[n] = t,\n  y = (E, n) => {\n    for (var t in n || (n = {})) Bt.call(n, t) && We(E, t, n[t]);\n    if (Be) for (var t of Be(n)) Wt.call(n, t) && We(E, t, n[t]);\n    return E;\n  },\n  M = (E, n) => Xt(E, Jt(n));\nclass Zt extends ht {\n  constructor(n) {\n    super(n), this.name = je, this.events = new Vt(), this.initialized = !1, this.requestQueue = {\n      state: D.idle,\n      queue: []\n    }, this.sessionRequestQueue = {\n      state: D.idle,\n      queue: []\n    }, this.requestQueueDelay = $t, this.expectedPairingMethodMap = new Map(), this.recentlyDeletedMap = new Map(), this.recentlyDeletedLimit = 200, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({\n        methods: Object.keys(R)\n      }), this.initialized = !0, setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();\n      }, Ke(this.requestQueueDelay)));\n    }, this.connect = async t => {\n      await this.isInitialized();\n      const e = M(y({}, t), {\n        requiredNamespaces: t.requiredNamespaces || {},\n        optionalNamespaces: t.optionalNamespaces || {}\n      });\n      await this.isValidConnect(e);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: i,\n        optionalNamespaces: r,\n        sessionProperties: o,\n        relays: a\n      } = e;\n      let c = s,\n        h,\n        d = !1;\n      try {\n        c && (d = this.client.core.pairing.pairings.get(c).active);\n      } catch (v) {\n        throw this.client.logger.error(`connect() -> pairing.get(${c}) failed`), v;\n      }\n      if (!c || !d) {\n        const {\n          topic: v,\n          uri: O\n        } = await this.client.core.pairing.create();\n        c = v, h = O;\n      }\n      if (!c) {\n        const {\n          message: v\n        } = l(\"NO_MATCHING_KEY\", `connect() pairing topic: ${c}`);\n        throw new Error(v);\n      }\n      const u = await this.client.core.crypto.generateKeyPair(),\n        p = R.wc_sessionPropose.req.ttl || q,\n        w = N(p),\n        m = y({\n          requiredNamespaces: i,\n          optionalNamespaces: r,\n          relays: a ?? [{\n            protocol: st\n          }],\n          proposer: {\n            publicKey: u,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: w,\n          pairingTopic: c\n        }, o && {\n          sessionProperties: o\n        }),\n        {\n          reject: S,\n          resolve: T,\n          done: _\n        } = G(p, Ge);\n      this.events.once(g(\"session_connect\"), async ({\n        error: v,\n        session: O\n      }) => {\n        if (v) S(v);else if (O) {\n          O.self.publicKey = u;\n          const F = M(y({}, O), {\n            pairingTopic: m.pairingTopic,\n            requiredNamespaces: m.requiredNamespaces,\n            optionalNamespaces: m.optionalNamespaces\n          });\n          await this.client.session.set(O.topic, F), await this.setExpiry(O.topic, O.expiry), c && (await this.client.core.pairing.updateMetadata({\n            topic: c,\n            metadata: O.peer.metadata\n          })), this.cleanupDuplicatePairings(F), T(F);\n        }\n      });\n      const P = await this.sendRequest({\n        topic: c,\n        method: \"wc_sessionPropose\",\n        params: m,\n        throwOnFailedPublish: !0\n      });\n      return await this.setProposal(P, y({\n        id: P\n      }, m)), {\n        uri: h,\n        approval: _\n      };\n    }, this.pair = async t => {\n      await this.isInitialized();\n      try {\n        return await this.client.core.pairing.pair(t);\n      } catch (e) {\n        throw this.client.logger.error(\"pair() failed\"), e;\n      }\n    }, this.approve = async t => {\n      await this.isInitialized();\n      try {\n        await this.isValidApprove(t);\n      } catch (_) {\n        throw this.client.logger.error(\"approve() -> isValidApprove() failed\"), _;\n      }\n      const {\n        id: e,\n        relayProtocol: s,\n        namespaces: i,\n        sessionProperties: r,\n        sessionConfig: o\n      } = t;\n      let a;\n      try {\n        a = this.client.proposal.get(e);\n      } catch (_) {\n        throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`), _;\n      }\n      const {\n          pairingTopic: c,\n          proposer: h,\n          requiredNamespaces: d,\n          optionalNamespaces: u\n        } = a,\n        p = await this.client.core.crypto.generateKeyPair(),\n        w = h.publicKey,\n        m = await this.client.core.crypto.generateSharedKey(p, w),\n        S = y(y({\n          relay: {\n            protocol: s ?? \"irn\"\n          },\n          namespaces: i,\n          controller: {\n            publicKey: p,\n            metadata: this.client.metadata\n          },\n          expiry: N(L)\n        }, r && {\n          sessionProperties: r\n        }), o && {\n          sessionConfig: o\n        });\n      await this.client.core.relayer.subscribe(m);\n      const T = M(y({}, S), {\n        topic: m,\n        requiredNamespaces: d,\n        optionalNamespaces: u,\n        pairingTopic: c,\n        acknowledged: !1,\n        self: S.controller,\n        peer: {\n          publicKey: h.publicKey,\n          metadata: h.metadata\n        },\n        controller: p\n      });\n      await this.client.session.set(m, T);\n      try {\n        await this.sendResult({\n          id: e,\n          topic: c,\n          result: {\n            relay: {\n              protocol: s ?? \"irn\"\n            },\n            responderPublicKey: p\n          },\n          throwOnFailedPublish: !0\n        }), await this.sendRequest({\n          topic: m,\n          method: \"wc_sessionSettle\",\n          params: S,\n          throwOnFailedPublish: !0\n        });\n      } catch (_) {\n        throw this.client.logger.error(_), this.client.session.delete(m, I(\"USER_DISCONNECTED\")), await this.client.core.relayer.unsubscribe(m), _;\n      }\n      return await this.client.core.pairing.updateMetadata({\n        topic: c,\n        metadata: h.metadata\n      }), await this.client.proposal.delete(e, I(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: c\n      }), await this.setExpiry(m, N(L)), {\n        topic: m,\n        acknowledged: () => new Promise(_ => setTimeout(() => _(this.client.session.get(m)), 500))\n      };\n    }, this.reject = async t => {\n      await this.isInitialized();\n      try {\n        await this.isValidReject(t);\n      } catch (r) {\n        throw this.client.logger.error(\"reject() -> isValidReject() failed\"), r;\n      }\n      const {\n        id: e,\n        reason: s\n      } = t;\n      let i;\n      try {\n        i = this.client.proposal.get(e).pairingTopic;\n      } catch (r) {\n        throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`), r;\n      }\n      i && (await this.sendError({\n        id: e,\n        topic: i,\n        error: s,\n        rpcOpts: R.wc_sessionPropose.reject\n      }), await this.client.proposal.delete(e, I(\"USER_DISCONNECTED\")));\n    }, this.update = async t => {\n      await this.isInitialized();\n      try {\n        await this.isValidUpdate(t);\n      } catch (d) {\n        throw this.client.logger.error(\"update() -> isValidUpdate() failed\"), d;\n      }\n      const {\n          topic: e,\n          namespaces: s\n        } = t,\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = G(),\n        a = j(),\n        c = se().toString(),\n        h = this.client.session.get(e).namespaces;\n      return this.events.once(g(\"session_update\", a), ({\n        error: d\n      }) => {\n        d ? o(d) : r();\n      }), await this.client.session.update(e, {\n        namespaces: s\n      }), await this.sendRequest({\n        topic: e,\n        method: \"wc_sessionUpdate\",\n        params: {\n          namespaces: s\n        },\n        throwOnFailedPublish: !0,\n        clientRpcId: a,\n        relayRpcId: c\n      }).catch(d => {\n        this.client.logger.error(d), this.client.session.update(e, {\n          namespaces: h\n        }), o(d);\n      }), {\n        acknowledged: i\n      };\n    }, this.extend = async t => {\n      await this.isInitialized();\n      try {\n        await this.isValidExtend(t);\n      } catch (a) {\n        throw this.client.logger.error(\"extend() -> isValidExtend() failed\"), a;\n      }\n      const {\n          topic: e\n        } = t,\n        s = j(),\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = G();\n      return this.events.once(g(\"session_extend\", s), ({\n        error: a\n      }) => {\n        a ? o(a) : r();\n      }), await this.setExpiry(e, N(L)), this.sendRequest({\n        topic: e,\n        method: \"wc_sessionExtend\",\n        params: {},\n        clientRpcId: s,\n        throwOnFailedPublish: !0\n      }).catch(a => {\n        o(a);\n      }), {\n        acknowledged: i\n      };\n    }, this.request = async t => {\n      await this.isInitialized();\n      try {\n        await this.isValidRequest(t);\n      } catch (p) {\n        throw this.client.logger.error(\"request() -> isValidRequest() failed\"), p;\n      }\n      const {\n          chainId: e,\n          request: s,\n          topic: i,\n          expiry: r = R.wc_sessionRequest.req.ttl\n        } = t,\n        o = this.client.session.get(i),\n        a = j(),\n        c = se().toString(),\n        {\n          done: h,\n          resolve: d,\n          reject: u\n        } = G(r, \"Request expired. Please try again.\");\n      return this.events.once(g(\"session_request\", a), ({\n        error: p,\n        result: w\n      }) => {\n        p ? u(p) : d(w);\n      }), await Promise.all([new Promise(async p => {\n        await this.sendRequest({\n          clientRpcId: a,\n          relayRpcId: c,\n          topic: i,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: M(y({}, s), {\n              expiryTimestamp: N(r)\n            }),\n            chainId: e\n          },\n          expiry: r,\n          throwOnFailedPublish: !0\n        }).catch(w => u(w)), this.client.events.emit(\"session_request_sent\", {\n          topic: i,\n          request: s,\n          chainId: e,\n          id: a\n        }), p();\n      }), new Promise(async p => {\n        var w;\n        if (!((w = o.sessionConfig) != null && w.disableDeepLink)) {\n          const m = await dt(this.client.core.storage, fe);\n          ut({\n            id: a,\n            topic: i,\n            wcDeepLink: m\n          });\n        }\n        p();\n      }), h()]).then(p => p[2]);\n    }, this.respond = async t => {\n      await this.isInitialized(), await this.isValidRespond(t);\n      const {\n          topic: e,\n          response: s\n        } = t,\n        {\n          id: i\n        } = s;\n      b(s) ? await this.sendResult({\n        id: i,\n        topic: e,\n        result: s.result,\n        throwOnFailedPublish: !0\n      }) : $(s) && (await this.sendError({\n        id: i,\n        topic: e,\n        error: s.error\n      })), this.cleanupAfterResponse(t);\n    }, this.ping = async t => {\n      await this.isInitialized();\n      try {\n        await this.isValidPing(t);\n      } catch (s) {\n        throw this.client.logger.error(\"ping() -> isValidPing() failed\"), s;\n      }\n      const {\n        topic: e\n      } = t;\n      if (this.client.session.keys.includes(e)) {\n        const s = j(),\n          i = se().toString(),\n          {\n            done: r,\n            resolve: o,\n            reject: a\n          } = G();\n        this.events.once(g(\"session_ping\", s), ({\n          error: c\n        }) => {\n          c ? a(c) : o();\n        }), await Promise.all([this.sendRequest({\n          topic: e,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: !0,\n          clientRpcId: s,\n          relayRpcId: i\n        }), r()]);\n      } else this.client.core.pairing.pairings.keys.includes(e) && (await this.client.core.pairing.ping({\n        topic: e\n      }));\n    }, this.emit = async t => {\n      await this.isInitialized(), await this.isValidEmit(t);\n      const {\n          topic: e,\n          event: s,\n          chainId: i\n        } = t,\n        r = se().toString();\n      await this.sendRequest({\n        topic: e,\n        method: \"wc_sessionEvent\",\n        params: {\n          event: s,\n          chainId: i\n        },\n        throwOnFailedPublish: !0,\n        relayRpcId: r\n      });\n    }, this.disconnect = async t => {\n      await this.isInitialized(), await this.isValidDisconnect(t);\n      const {\n        topic: e\n      } = t;\n      if (this.client.session.keys.includes(e)) await this.sendRequest({\n        topic: e,\n        method: \"wc_sessionDelete\",\n        params: I(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: !0\n      }), await this.deleteSession({\n        topic: e,\n        emitEvent: !1\n      });else if (this.client.core.pairing.pairings.keys.includes(e)) await this.client.core.pairing.disconnect({\n        topic: e\n      });else {\n        const {\n          message: s\n        } = l(\"MISMATCHED_TOPIC\", `Session or pairing topic not found: ${e}`);\n        throw new Error(s);\n      }\n    }, this.find = t => (this.isInitialized(), this.client.session.getAll().filter(e => gt(e, t))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async t => {\n      this.isInitialized(), this.isValidAuthenticate(t);\n      const {\n          chains: e,\n          statement: s = \"\",\n          uri: i,\n          domain: r,\n          nonce: o,\n          type: a,\n          exp: c,\n          nbf: h,\n          methods: d = [],\n          expiry: u\n        } = t,\n        p = [...(t.resources || [])],\n        {\n          topic: w,\n          uri: m\n        } = await this.client.core.pairing.create({\n          methods: [\"wc_sessionAuthenticate\"]\n        });\n      this.client.logger.info({\n        message: \"Generated new pairing\",\n        pairing: {\n          topic: w,\n          uri: m\n        }\n      });\n      const S = await this.client.core.crypto.generateKeyPair(),\n        T = ue(S);\n      if (await Promise.all([this.client.auth.authKeys.set(B, {\n        responseTopic: T,\n        publicKey: S\n      }), this.client.auth.pairingTopics.set(T, {\n        topic: T,\n        pairingTopic: w\n      })]), await this.client.core.relayer.subscribe(T), this.client.logger.info(`sending request to new pairing topic: ${w}`), d.length > 0) {\n        const {\n          namespace: A\n        } = ge(e[0]);\n        let f = wt(A, \"request\", d);\n        we(p) && (f = mt(f, p.pop())), p.push(f);\n      }\n      const _ = u && u > R.wc_sessionAuthenticate.req.ttl ? u : R.wc_sessionAuthenticate.req.ttl,\n        P = {\n          authPayload: {\n            type: a ?? \"caip122\",\n            chains: e,\n            statement: s,\n            aud: i,\n            domain: r,\n            version: \"1\",\n            nonce: o,\n            iat: new Date().toISOString(),\n            exp: c,\n            nbf: h,\n            resources: p\n          },\n          requester: {\n            publicKey: S,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: N(_)\n        },\n        v = {\n          eip155: {\n            chains: e,\n            methods: [...new Set([\"personal_sign\", ...d])],\n            events: [\"chainChanged\", \"accountsChanged\"]\n          }\n        },\n        O = {\n          requiredNamespaces: {},\n          optionalNamespaces: v,\n          relays: [{\n            protocol: \"irn\"\n          }],\n          pairingTopic: w,\n          proposer: {\n            publicKey: S,\n            metadata: this.client.metadata\n          },\n          expiryTimestamp: N(R.wc_sessionPropose.req.ttl)\n        },\n        {\n          done: F,\n          resolve: Ie,\n          reject: ae\n        } = G(_, \"Request expired\"),\n        W = async ({\n          error: A,\n          session: f\n        }) => {\n          if (this.events.off(g(\"session_request\", K), ce), A) ae(A);else if (f) {\n            f.self.publicKey = S, await this.client.session.set(f.topic, f), await this.setExpiry(f.topic, f.expiry), w && (await this.client.core.pairing.updateMetadata({\n              topic: w,\n              metadata: f.peer.metadata\n            }));\n            const z = this.client.session.get(f.topic);\n            await this.deleteProposal(Q), Ie({\n              session: z\n            });\n          }\n        },\n        ce = async A => {\n          if (await this.deletePendingAuthRequest(K, {\n            message: \"fulfilled\",\n            code: 0\n          }), A.error) {\n            const H = I(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n            return A.error.code === H.code ? void 0 : (this.events.off(g(\"session_connect\"), W), ae(A.error.message));\n          }\n          await this.deleteProposal(Q), this.events.off(g(\"session_connect\"), W);\n          const {\n              cacaos: f,\n              responder: z\n            } = A.result,\n            le = [],\n            qe = [];\n          for (const H of f) {\n            (await Oe({\n              cacao: H,\n              projectId: this.client.core.projectId\n            })) || (this.client.logger.error(H, \"Signature verification failed\"), ae(I(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\")));\n            const {\n                p: he\n              } = H,\n              pe = we(he.resources),\n              Ne = [Te(he.iss)],\n              et = Ae(he.iss);\n            if (pe) {\n              const de = xe(pe),\n                tt = De(pe);\n              le.push(...de), Ne.push(...tt);\n            }\n            for (const de of Ne) qe.push(`${de}:${et}`);\n          }\n          const Z = await this.client.core.crypto.generateSharedKey(S, z.publicKey);\n          let ee;\n          le.length > 0 && (ee = {\n            topic: Z,\n            acknowledged: !0,\n            self: {\n              publicKey: S,\n              metadata: this.client.metadata\n            },\n            peer: z,\n            controller: z.publicKey,\n            expiry: N(L),\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            relay: {\n              protocol: \"irn\"\n            },\n            pairingTopic: w,\n            namespaces: Ve([...new Set(le)], [...new Set(qe)])\n          }, await this.client.core.relayer.subscribe(Z), await this.client.session.set(Z, ee), ee = this.client.session.get(Z)), Ie({\n            auths: f,\n            session: ee\n          });\n        },\n        K = j(),\n        Q = j();\n      this.events.once(g(\"session_connect\"), W), this.events.once(g(\"session_request\", K), ce);\n      try {\n        await Promise.all([this.sendRequest({\n          topic: w,\n          method: \"wc_sessionAuthenticate\",\n          params: P,\n          expiry: t.expiry,\n          throwOnFailedPublish: !0,\n          clientRpcId: K\n        }), this.sendRequest({\n          topic: w,\n          method: \"wc_sessionPropose\",\n          params: O,\n          expiry: R.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: !0,\n          clientRpcId: Q\n        })]);\n      } catch (A) {\n        throw this.events.off(g(\"session_connect\"), W), this.events.off(g(\"session_request\", K), ce), A;\n      }\n      return await this.setProposal(Q, y({\n        id: Q\n      }, O)), await this.setAuthRequest(K, {\n        request: M(y({}, P), {\n          verifyContext: {}\n        }),\n        pairingTopic: w\n      }), {\n        uri: m,\n        response: F\n      };\n    }, this.approveSessionAuthenticate = async t => {\n      this.isInitialized();\n      const {\n          id: e,\n          auths: s\n        } = t,\n        i = this.getPendingAuthRequest(e);\n      if (!i) throw new Error(`Could not find pending auth request with id ${e}`);\n      const r = i.requester.publicKey,\n        o = await this.client.core.crypto.generateKeyPair(),\n        a = ue(r),\n        c = {\n          type: ye,\n          receiverPublicKey: r,\n          senderPublicKey: o\n        },\n        h = [],\n        d = [];\n      for (const w of s) {\n        if (!(await Oe({\n          cacao: w,\n          projectId: this.client.core.projectId\n        }))) {\n          const P = I(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\");\n          throw await this.sendError({\n            id: e,\n            topic: a,\n            error: P,\n            encodeOpts: c\n          }), new Error(P.message);\n        }\n        const {\n            p: m\n          } = w,\n          S = we(m.resources),\n          T = [Te(m.iss)],\n          _ = Ae(m.iss);\n        if (S) {\n          const P = xe(S),\n            v = De(S);\n          h.push(...P), T.push(...v);\n        }\n        for (const P of T) d.push(`${P}:${_}`);\n      }\n      const u = await this.client.core.crypto.generateSharedKey(o, r);\n      let p;\n      return h?.length > 0 && (p = {\n        topic: u,\n        acknowledged: !0,\n        self: {\n          publicKey: o,\n          metadata: this.client.metadata\n        },\n        peer: {\n          publicKey: r,\n          metadata: i.requester.metadata\n        },\n        controller: r,\n        expiry: N(L),\n        authentication: s,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: {\n          protocol: \"irn\"\n        },\n        pairingTopic: \"\",\n        namespaces: Ve([...new Set(h)], [...new Set(d)])\n      }, await this.client.core.relayer.subscribe(u), await this.client.session.set(u, p)), await this.sendResult({\n        topic: a,\n        id: e,\n        result: {\n          cacaos: s,\n          responder: {\n            publicKey: o,\n            metadata: this.client.metadata\n          }\n        },\n        encodeOpts: c,\n        throwOnFailedPublish: !0\n      }), await this.client.auth.requests.delete(e, {\n        message: \"fulfilled\",\n        code: 0\n      }), await this.client.core.pairing.activate({\n        topic: i.pairingTopic\n      }), {\n        session: p\n      };\n    }, this.rejectSessionAuthenticate = async t => {\n      await this.isInitialized();\n      const {\n          id: e,\n          reason: s\n        } = t,\n        i = this.getPendingAuthRequest(e);\n      if (!i) throw new Error(`Could not find pending auth request with id ${e}`);\n      const r = i.requester.publicKey,\n        o = await this.client.core.crypto.generateKeyPair(),\n        a = ue(r),\n        c = {\n          type: ye,\n          receiverPublicKey: r,\n          senderPublicKey: o\n        };\n      await this.sendError({\n        id: e,\n        topic: a,\n        error: s,\n        encodeOpts: c,\n        rpcOpts: R.wc_sessionAuthenticate.reject\n      }), await this.client.auth.requests.delete(e, {\n        message: \"rejected\",\n        code: 0\n      }), await this.client.proposal.delete(e, I(\"USER_DISCONNECTED\"));\n    }, this.formatAuthMessage = t => {\n      this.isInitialized();\n      const {\n        request: e,\n        iss: s\n      } = t;\n      return yt(e, s);\n    }, this.cleanupDuplicatePairings = async t => {\n      if (t.pairingTopic) try {\n        const e = this.client.core.pairing.pairings.get(t.pairingTopic),\n          s = this.client.core.pairing.pairings.getAll().filter(i => {\n            var r, o;\n            return ((r = i.peerMetadata) == null ? void 0 : r.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === t.peer.metadata.url && i.topic && i.topic !== e.topic;\n          });\n        if (s.length === 0) return;\n        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (e) {\n        this.client.logger.error(e);\n      }\n    }, this.deleteSession = async t => {\n      var e;\n      const {\n          topic: s,\n          expirerHasDeleted: i = !1,\n          emitEvent: r = !0,\n          id: o = 0\n        } = t,\n        {\n          self: a\n        } = this.client.session.get(s);\n      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, I(\"USER_DISCONNECTED\")), this.addToRecentlyDeleted(s, \"session\"), this.client.core.crypto.keychain.has(a.publicKey) && (await this.client.core.crypto.deleteKeyPair(a.publicKey)), this.client.core.crypto.keychain.has(s) && (await this.client.core.crypto.deleteSymKey(s)), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(fe).catch(c => this.client.logger.warn(c)), this.getPendingSessionRequests().forEach(c => {\n        c.topic === s && this.deletePendingSessionRequest(c.id, I(\"USER_DISCONNECTED\"));\n      }), s === ((e = this.sessionRequestQueue.queue[0]) == null ? void 0 : e.topic) && (this.sessionRequestQueue.state = D.idle), r && this.client.events.emit(\"session_delete\", {\n        id: o,\n        topic: s\n      });\n    }, this.deleteProposal = async (t, e) => {\n      await Promise.all([this.client.proposal.delete(t, I(\"USER_DISCONNECTED\")), e ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, \"proposal\");\n    }, this.deletePendingSessionRequest = async (t, e, s = !1) => {\n      await Promise.all([this.client.pendingRequest.delete(t, e), s ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, \"request\"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(i => i.id !== t), s && (this.sessionRequestQueue.state = D.idle, this.client.events.emit(\"session_request_expire\", {\n        id: t\n      }));\n    }, this.deletePendingAuthRequest = async (t, e, s = !1) => {\n      await Promise.all([this.client.auth.requests.delete(t, e), s ? Promise.resolve() : this.client.core.expirer.del(t)]);\n    }, this.setExpiry = async (t, e) => {\n      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, e), await this.client.session.update(t, {\n        expiry: e\n      }));\n    }, this.setProposal = async (t, e) => {\n      this.client.core.expirer.set(t, N(R.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, e);\n    }, this.setAuthRequest = async (t, e) => {\n      const {\n        request: s,\n        pairingTopic: i\n      } = e;\n      this.client.core.expirer.set(t, s.expiryTimestamp), await this.client.auth.requests.set(t, {\n        authPayload: s.authPayload,\n        requester: s.requester,\n        expiryTimestamp: s.expiryTimestamp,\n        id: t,\n        pairingTopic: i,\n        verifyContext: s.verifyContext\n      });\n    }, this.setPendingSessionRequest = async t => {\n      const {\n          id: e,\n          topic: s,\n          params: i,\n          verifyContext: r\n        } = t,\n        o = i.request.expiryTimestamp || N(R.wc_sessionRequest.req.ttl);\n      this.client.core.expirer.set(e, o), await this.client.pendingRequest.set(e, {\n        id: e,\n        topic: s,\n        params: i,\n        verifyContext: r\n      });\n    }, this.sendRequest = async t => {\n      const {\n          topic: e,\n          method: s,\n          params: i,\n          expiry: r,\n          relayRpcId: o,\n          clientRpcId: a,\n          throwOnFailedPublish: c\n        } = t,\n        h = Re(s, i, a);\n      if (Rt() && Qe.includes(s)) {\n        const p = te(JSON.stringify(h));\n        this.client.core.verify.register({\n          attestationId: p\n        });\n      }\n      let d;\n      try {\n        d = await this.client.core.crypto.encode(e, h);\n      } catch (p) {\n        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`), p;\n      }\n      const u = R[s].req;\n      return r && (u.ttl = r), o && (u.id = o), this.client.core.history.set(e, h), c ? (u.internal = M(y({}, u.internal), {\n        throwOnFailedPublish: !0\n      }), await this.client.core.relayer.publish(e, d, u)) : this.client.core.relayer.publish(e, d, u).catch(p => this.client.logger.error(p)), h.id;\n    }, this.sendResult = async t => {\n      const {\n          id: e,\n          topic: s,\n          result: i,\n          throwOnFailedPublish: r,\n          encodeOpts: o\n        } = t,\n        a = Lt(e, i);\n      let c;\n      try {\n        c = await this.client.core.crypto.encode(s, a, o);\n      } catch (u) {\n        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), u;\n      }\n      let h;\n      try {\n        h = await this.client.core.history.get(s, e);\n      } catch (u) {\n        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`), u;\n      }\n      const d = R[h.request.method].res;\n      r ? (d.internal = M(y({}, d.internal), {\n        throwOnFailedPublish: !0\n      }), await this.client.core.relayer.publish(s, c, d)) : this.client.core.relayer.publish(s, c, d).catch(u => this.client.logger.error(u)), await this.client.core.history.resolve(a);\n    }, this.sendError = async t => {\n      const {\n          id: e,\n          topic: s,\n          error: i,\n          encodeOpts: r,\n          rpcOpts: o\n        } = t,\n        a = Mt(e, i);\n      let c;\n      try {\n        c = await this.client.core.crypto.encode(s, a, r);\n      } catch (u) {\n        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), u;\n      }\n      let h;\n      try {\n        h = await this.client.core.history.get(s, e);\n      } catch (u) {\n        throw this.client.logger.error(`sendError() -> history.get(${s}, ${e}) failed`), u;\n      }\n      const d = o || R[h.request.method].res;\n      this.client.core.relayer.publish(s, c, d), await this.client.core.history.resolve(a);\n    }, this.cleanup = async () => {\n      const t = [],\n        e = [];\n      this.client.session.getAll().forEach(s => {\n        let i = !1;\n        k(s.expiry) && (i = !0), this.client.core.crypto.keychain.has(s.topic) || (i = !0), i && t.push(s.topic);\n      }), this.client.proposal.getAll().forEach(s => {\n        k(s.expiryTimestamp) && e.push(s.id);\n      }), await Promise.all([...t.map(s => this.deleteSession({\n        topic: s\n      })), ...e.map(s => this.deleteProposal(s))]);\n    }, this.onRelayEventRequest = async t => {\n      this.requestQueue.queue.push(t), await this.processRequestsQueue();\n    }, this.processRequestsQueue = async () => {\n      if (this.requestQueue.state === D.active) {\n        this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {\n        this.requestQueue.state = D.active;\n        const t = this.requestQueue.queue.shift();\n        if (t) try {\n          this.processRequest(t), await new Promise(e => setTimeout(e, 300));\n        } catch (e) {\n          this.client.logger.warn(e);\n        }\n      }\n      this.requestQueue.state = D.idle;\n    }, this.processRequest = t => {\n      const {\n          topic: e,\n          payload: s\n        } = t,\n        i = s.method;\n      if (!this.shouldIgnorePairingRequest({\n        topic: e,\n        requestMethod: i\n      })) switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(e, s);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(e, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(e, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(e, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(e, s);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(e, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(e, s);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(e, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateRequest(e, s);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async t => {\n      const {\n          topic: e,\n          payload: s\n        } = t,\n        i = (await this.client.core.history.get(e, s.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(e, s);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(e, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(e, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(e, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(e, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(e, s);\n        case \"wc_sessionAuthenticate\":\n          return this.onSessionAuthenticateResponse(e, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onRelayEventUnknownPayload = t => {\n      const {\n          topic: e\n        } = t,\n        {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", `Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);\n      throw new Error(s);\n    }, this.shouldIgnorePairingRequest = t => {\n      const {\n          topic: e,\n          requestMethod: s\n        } = t,\n        i = this.expectedPairingMethodMap.get(e);\n      return !i || i.includes(s) ? !1 : !!(i.includes(\"wc_sessionAuthenticate\") && this.client.events.listenerCount(\"session_authenticate\") > 0);\n    }, this.onSessionProposeRequest = async (t, e) => {\n      const {\n        params: s,\n        id: i\n      } = e;\n      try {\n        this.isValidConnect(y({}, e.params));\n        const r = s.expiryTimestamp || N(R.wc_sessionPropose.req.ttl),\n          o = y({\n            id: i,\n            pairingTopic: t,\n            expiryTimestamp: r\n          }, s);\n        await this.setProposal(i, o);\n        const a = te(JSON.stringify(e)),\n          c = await this.getVerifyContext(a, o.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: o,\n          verifyContext: c\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: t,\n          error: r,\n          rpcOpts: R.wc_sessionPropose.autoReject\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionProposeResponse = async (t, e) => {\n      const {\n        id: s\n      } = e;\n      if (b(e)) {\n        const {\n          result: i\n        } = e;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const r = this.client.proposal.get(s);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: r\n        });\n        const o = r.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: o\n        });\n        const a = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: a\n        });\n        const c = await this.client.core.crypto.generateSharedKey(o, a);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: c\n        });\n        const h = await this.client.core.relayer.subscribe(c);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: t\n        });\n      } else if ($(e)) {\n        await this.client.proposal.delete(s, I(\"USER_DISCONNECTED\"));\n        const i = g(\"session_connect\");\n        if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners, 954`);\n        this.events.emit(g(\"session_connect\"), {\n          error: e.error\n        });\n      }\n    }, this.onSessionSettleRequest = async (t, e) => {\n      const {\n        id: s,\n        params: i\n      } = e;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: o,\n            expiry: a,\n            namespaces: c,\n            sessionProperties: h,\n            sessionConfig: d\n          } = e.params,\n          u = y(y({\n            topic: t,\n            relay: r,\n            expiry: a,\n            namespaces: c,\n            acknowledged: !0,\n            pairingTopic: \"\",\n            requiredNamespaces: {},\n            optionalNamespaces: {},\n            controller: o.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          }, h && {\n            sessionProperties: h\n          }), d && {\n            sessionConfig: d\n          });\n        await this.sendResult({\n          id: e.id,\n          topic: t,\n          result: !0,\n          throwOnFailedPublish: !0\n        });\n        const p = g(\"session_connect\");\n        if (this.events.listenerCount(p) === 0) throw new Error(`emitting ${p} without any listeners 997`);\n        this.events.emit(g(\"session_connect\"), {\n          session: u\n        });\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: t,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionSettleResponse = async (t, e) => {\n      const {\n        id: s\n      } = e;\n      b(e) ? (await this.client.session.update(t, {\n        acknowledged: !0\n      }), this.events.emit(g(\"session_approve\", s), {})) : $(e) && (await this.client.session.delete(t, I(\"USER_DISCONNECTED\")), this.events.emit(g(\"session_approve\", s), {\n        error: e.error\n      }));\n    }, this.onSessionUpdateRequest = async (t, e) => {\n      const {\n        params: s,\n        id: i\n      } = e;\n      try {\n        const r = `${t}_session_update`,\n          o = Y.get(r);\n        if (o && this.isRequestOutOfSync(o, i)) {\n          this.client.logger.info(`Discarding out of sync request - ${i}`), this.sendError({\n            id: i,\n            topic: t,\n            error: I(\"INVALID_UPDATE_REQUEST\")\n          });\n          return;\n        }\n        this.isValidUpdate(y({\n          topic: t\n        }, s));\n        try {\n          Y.set(r, i), await this.client.session.update(t, {\n            namespaces: s.namespaces\n          }), await this.sendResult({\n            id: i,\n            topic: t,\n            result: !0,\n            throwOnFailedPublish: !0\n          });\n        } catch (a) {\n          throw Y.delete(r), a;\n        }\n        this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: t,\n          params: s\n        });\n      } catch (r) {\n        await this.sendError({\n          id: i,\n          topic: t,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.isRequestOutOfSync = (t, e) => parseInt(e.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, e) => {\n      const {\n          id: s\n        } = e,\n        i = g(\"session_update\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      b(e) ? this.events.emit(g(\"session_update\", s), {}) : $(e) && this.events.emit(g(\"session_update\", s), {\n        error: e.error\n      });\n    }, this.onSessionExtendRequest = async (t, e) => {\n      const {\n        id: s\n      } = e;\n      try {\n        this.isValidExtend({\n          topic: t\n        }), await this.setExpiry(t, N(L)), await this.sendResult({\n          id: s,\n          topic: t,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: t\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: t,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (t, e) => {\n      const {\n          id: s\n        } = e,\n        i = g(\"session_extend\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      b(e) ? this.events.emit(g(\"session_extend\", s), {}) : $(e) && this.events.emit(g(\"session_extend\", s), {\n        error: e.error\n      });\n    }, this.onSessionPingRequest = async (t, e) => {\n      const {\n        id: s\n      } = e;\n      try {\n        this.isValidPing({\n          topic: t\n        }), await this.sendResult({\n          id: s,\n          topic: t,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: t\n        });\n      } catch (i) {\n        await this.sendError({\n          id: s,\n          topic: t,\n          error: i\n        }), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (t, e) => {\n      const {\n          id: s\n        } = e,\n        i = g(\"session_ping\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      setTimeout(() => {\n        b(e) ? this.events.emit(g(\"session_ping\", s), {}) : $(e) && this.events.emit(g(\"session_ping\", s), {\n          error: e.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (t, e) => {\n      const {\n        id: s\n      } = e;\n      try {\n        this.isValidDisconnect({\n          topic: t,\n          reason: e.params\n        }), await Promise.all([new Promise(i => {\n          this.client.core.relayer.once(Pe.publish, async () => {\n            i(await this.deleteSession({\n              topic: t,\n              id: s\n            }));\n          });\n        }), this.sendResult({\n          id: s,\n          topic: t,\n          result: !0,\n          throwOnFailedPublish: !0\n        }), this.cleanupPendingSentRequestsForTopic({\n          topic: t,\n          error: I(\"USER_DISCONNECTED\")\n        })]);\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (t, e) => {\n      var s;\n      const {\n        id: i,\n        params: r\n      } = e;\n      try {\n        await this.isValidRequest(y({\n          topic: t\n        }, r));\n        const o = te(JSON.stringify(Re(\"wc_sessionRequest\", r, i))),\n          a = this.client.session.get(t),\n          c = await this.getVerifyContext(o, a.peer.metadata),\n          h = {\n            id: i,\n            topic: t,\n            params: r,\n            verifyContext: c\n          };\n        await this.setPendingSessionRequest(h), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(h) : (this.addSessionRequestToSessionRequestQueue(h), this.processSessionRequestQueue());\n      } catch (o) {\n        await this.sendError({\n          id: i,\n          topic: t,\n          error: o\n        }), this.client.logger.error(o);\n      }\n    }, this.onSessionRequestResponse = (t, e) => {\n      const {\n          id: s\n        } = e,\n        i = g(\"session_request\", s);\n      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);\n      b(e) ? this.events.emit(g(\"session_request\", s), {\n        result: e.result\n      }) : $(e) && this.events.emit(g(\"session_request\", s), {\n        error: e.error\n      });\n    }, this.onSessionEventRequest = async (t, e) => {\n      const {\n        id: s,\n        params: i\n      } = e;\n      try {\n        const r = `${t}_session_event_${i.event.name}`,\n          o = Y.get(r);\n        if (o && this.isRequestOutOfSync(o, s)) {\n          this.client.logger.info(`Discarding out of sync request - ${s}`);\n          return;\n        }\n        this.isValidEmit(y({\n          topic: t\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: t,\n          params: i\n        }), Y.set(r, s);\n      } catch (r) {\n        await this.sendError({\n          id: s,\n          topic: t,\n          error: r\n        }), this.client.logger.error(r);\n      }\n    }, this.onSessionAuthenticateResponse = (t, e) => {\n      const {\n        id: s\n      } = e;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionAuthenticateResponse\",\n        topic: t,\n        payload: e\n      }), b(e) ? this.events.emit(g(\"session_request\", s), {\n        result: e.result\n      }) : $(e) && this.events.emit(g(\"session_request\", s), {\n        error: e.error\n      });\n    }, this.onSessionAuthenticateRequest = async (t, e) => {\n      try {\n        const {\n            requester: s,\n            authPayload: i,\n            expiryTimestamp: r\n          } = e.params,\n          o = te(JSON.stringify(e)),\n          a = await this.getVerifyContext(o, this.client.metadata),\n          c = {\n            requester: s,\n            pairingTopic: t,\n            id: e.id,\n            authPayload: i,\n            verifyContext: a,\n            expiryTimestamp: r\n          };\n        await this.setAuthRequest(e.id, {\n          request: c,\n          pairingTopic: t\n        }), this.client.events.emit(\"session_authenticate\", {\n          topic: t,\n          params: e.params,\n          id: e.id\n        });\n      } catch (s) {\n        this.client.logger.error(s);\n        const i = e.params.requester.publicKey,\n          r = await this.client.core.crypto.generateKeyPair(),\n          o = {\n            type: ye,\n            receiverPublicKey: i,\n            senderPublicKey: r\n          };\n        await this.sendError({\n          id: e.id,\n          topic: t,\n          error: s,\n          encodeOpts: o,\n          rpcOpts: R.wc_sessionAuthenticate.autoReject\n        });\n      }\n    }, this.addSessionRequestToSessionRequestQueue = t => {\n      this.sessionRequestQueue.queue.push(t);\n    }, this.cleanupAfterResponse = t => {\n      this.deletePendingSessionRequest(t.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = D.idle, this.processSessionRequestQueue();\n      }, Ke(this.requestQueueDelay));\n    }, this.cleanupPendingSentRequestsForTopic = ({\n      topic: t,\n      error: e\n    }) => {\n      const s = this.client.core.history.pending;\n      s.length > 0 && s.filter(i => i.topic === t && i.request.method === \"wc_sessionRequest\").forEach(i => {\n        const r = i.request.id,\n          o = g(\"session_request\", r);\n        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners`);\n        this.events.emit(g(\"session_request\", i.request.id), {\n          error: e\n        });\n      });\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === D.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const t = this.sessionRequestQueue.queue[0];\n      if (!t) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = D.active, this.emitSessionRequest(t);\n      } catch (e) {\n        this.client.logger.error(e);\n      }\n    }, this.emitSessionRequest = t => {\n      this.client.events.emit(\"session_request\", t);\n    }, this.onPairingCreated = t => {\n      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;\n      const e = this.client.proposal.getAll().find(s => s.pairingTopic === t.topic);\n      e && this.onSessionProposeRequest(t.topic, Re(\"wc_sessionPropose\", {\n        requiredNamespaces: e.requiredNamespaces,\n        optionalNamespaces: e.optionalNamespaces,\n        relays: e.relays,\n        proposer: e.proposer,\n        sessionProperties: e.sessionProperties\n      }, e.id));\n    }, this.isValidConnect = async t => {\n      if (!x(t)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: e,\n        requiredNamespaces: s,\n        optionalNamespaces: i,\n        sessionProperties: r,\n        relays: o\n      } = t;\n      if (X(e) || (await this.isValidPairingTopic(e)), !Et(o, !0)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `connect() relays: ${o}`);\n        throw new Error(a);\n      }\n      !X(s) && Ce(s) !== 0 && this.validateNamespaces(s, \"requiredNamespaces\"), !X(i) && Ce(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), X(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.validateNamespaces = (t, e) => {\n      const s = St(t, \"connect()\", e);\n      if (s) throw new Error(s.message);\n    }, this.isValidApprove = async t => {\n      if (!x(t)) throw new Error(l(\"MISSING_OR_INVALID\", `approve() params: ${t}`).message);\n      const {\n        id: e,\n        namespaces: s,\n        relayProtocol: i,\n        sessionProperties: r\n      } = t;\n      this.checkRecentlyDeleted(e), await this.isValidProposalId(e);\n      const o = this.client.proposal.get(e),\n        a = me(s, \"approve()\");\n      if (a) throw new Error(a.message);\n      const c = be(o.requiredNamespaces, s, \"approve()\");\n      if (c) throw new Error(c.message);\n      if (!V(i, !0)) {\n        const {\n          message: h\n        } = l(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      X(r) || this.validateSessionProps(r, \"sessionProperties\");\n    }, this.isValidReject = async t => {\n      if (!x(t)) {\n        const {\n          message: i\n        } = l(\"MISSING_OR_INVALID\", `reject() params: ${t}`);\n        throw new Error(i);\n      }\n      const {\n        id: e,\n        reason: s\n      } = t;\n      if (this.checkRecentlyDeleted(e), await this.isValidProposalId(e), !_t(s)) {\n        const {\n          message: i\n        } = l(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = t => {\n      if (!x(t)) {\n        const {\n          message: c\n        } = l(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${t}`);\n        throw new Error(c);\n      }\n      const {\n        relay: e,\n        controller: s,\n        namespaces: i,\n        expiry: r\n      } = t;\n      if (!ft(e)) {\n        const {\n          message: c\n        } = l(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(c);\n      }\n      const o = It(s, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = me(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (k(r)) {\n        const {\n          message: c\n        } = l(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(c);\n      }\n    }, this.isValidUpdate = async t => {\n      if (!x(t)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `update() params: ${t}`);\n        throw new Error(a);\n      }\n      const {\n        topic: e,\n        namespaces: s\n      } = t;\n      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);\n      const i = this.client.session.get(e),\n        r = me(s, \"update()\");\n      if (r) throw new Error(r.message);\n      const o = be(i.requiredNamespaces, s, \"update()\");\n      if (o) throw new Error(o.message);\n    }, this.isValidExtend = async t => {\n      if (!x(t)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", `extend() params: ${t}`);\n        throw new Error(s);\n      }\n      const {\n        topic: e\n      } = t;\n      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);\n    }, this.isValidRequest = async t => {\n      if (!x(t)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() params: ${t}`);\n        throw new Error(a);\n      }\n      const {\n        topic: e,\n        request: s,\n        chainId: i,\n        expiry: r\n      } = t;\n      this.checkRecentlyDeleted(e), await this.isValidSessionTopic(e);\n      const {\n        namespaces: o\n      } = this.client.session.get(e);\n      if (!$e(o, i)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!qt(s)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!Nt(o, i, s.method)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n      if (r && !Pt(r, ne)) {\n        const {\n          message: a\n        } = l(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${ne.min} and ${ne.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async t => {\n      var e;\n      if (!x(t)) {\n        const {\n          message: r\n        } = l(\"MISSING_OR_INVALID\", `respond() params: ${t}`);\n        throw new Error(r);\n      }\n      const {\n        topic: s,\n        response: i\n      } = t;\n      try {\n        await this.isValidSessionTopic(s);\n      } catch (r) {\n        throw (e = t?.response) != null && e.id && this.cleanupAfterResponse(t), r;\n      }\n      if (!vt(i)) {\n        const {\n          message: r\n        } = l(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(i)}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async t => {\n      if (!x(t)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", `ping() params: ${t}`);\n        throw new Error(s);\n      }\n      const {\n        topic: e\n      } = t;\n      await this.isValidSessionOrPairingTopic(e);\n    }, this.isValidEmit = async t => {\n      if (!x(t)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() params: ${t}`);\n        throw new Error(o);\n      }\n      const {\n        topic: e,\n        event: s,\n        chainId: i\n      } = t;\n      await this.isValidSessionTopic(e);\n      const {\n        namespaces: r\n      } = this.client.session.get(e);\n      if (!$e(r, i)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!Ot(s)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n      if (!Tt(r, i, s.name)) {\n        const {\n          message: o\n        } = l(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(o);\n      }\n    }, this.isValidDisconnect = async t => {\n      if (!x(t)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", `disconnect() params: ${t}`);\n        throw new Error(s);\n      }\n      const {\n        topic: e\n      } = t;\n      await this.isValidSessionOrPairingTopic(e);\n    }, this.isValidAuthenticate = t => {\n      const {\n        chains: e,\n        uri: s,\n        domain: i,\n        nonce: r\n      } = t;\n      if (!Array.isArray(e) || e.length === 0) throw new Error(\"chains is required and must be a non-empty array\");\n      if (!V(s, !1)) throw new Error(\"uri is required parameter\");\n      if (!V(i, !1)) throw new Error(\"domain is required parameter\");\n      if (!V(r, !1)) throw new Error(\"nonce is required parameter\");\n      if ([...new Set(e.map(a => ge(a).namespace))].length > 1) throw new Error(\"Multi-namespace requests are not supported. Please request single namespace only.\");\n      const {\n        namespace: o\n      } = ge(e[0]);\n      if (o !== \"eip155\") throw new Error(\"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\");\n    }, this.getVerifyContext = async (t, e) => {\n      const s = {\n        verified: {\n          verifyUrl: e.verifyUrl || it,\n          validation: \"UNKNOWN\",\n          origin: e.url || \"\"\n        }\n      };\n      try {\n        const i = await this.client.core.verify.resolve({\n          attestationId: t,\n          verifyUrl: e.verifyUrl\n        });\n        i && (s.verified.origin = i.origin, s.verified.isScam = i.isScam, s.verified.validation = i.origin === new URL(e.url).origin ? \"VALID\" : \"INVALID\");\n      } catch (i) {\n        this.client.logger.info(i);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(s)}`), s;\n    }, this.validateSessionProps = (t, e) => {\n      Object.values(t).forEach(s => {\n        if (!V(s, !1)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", `${e} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);\n          throw new Error(i);\n        }\n      });\n    }, this.getPendingAuthRequest = t => {\n      const e = this.client.auth.requests.get(t);\n      return typeof e == \"object\" ? e : void 0;\n    }, this.addToRecentlyDeleted = (t, e) => {\n      if (this.recentlyDeletedMap.set(t, e), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n        let s = 0;\n        const i = this.recentlyDeletedLimit / 2;\n        for (const r of this.recentlyDeletedMap.keys()) {\n          if (s++ >= i) break;\n          this.recentlyDeletedMap.delete(r);\n        }\n      }\n    }, this.checkRecentlyDeleted = t => {\n      const e = this.recentlyDeletedMap.get(t);\n      if (e) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", `Record was recently deleted - ${e}: ${t}`);\n        throw new Error(s);\n      }\n    };\n  }\n  async isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(Pe.message, async n => {\n      const {\n          topic: t,\n          message: e\n        } = n,\n        {\n          publicKey: s\n        } = this.client.auth.authKeys.keys.includes(B) ? this.client.auth.authKeys.get(B) : {\n          responseTopic: void 0,\n          publicKey: void 0\n        },\n        i = await this.client.core.crypto.decode(t, e, {\n          receiverPublicKey: s\n        });\n      try {\n        Kt(i) ? (this.client.core.history.set(t, i), this.onRelayEventRequest({\n          topic: t,\n          payload: i\n        })) : Ut(i) ? (await this.client.core.history.resolve(i), await this.onRelayEventResponse({\n          topic: t,\n          payload: i\n        }), this.client.core.history.delete(t, i.id)) : this.onRelayEventUnknownPayload({\n          topic: t,\n          payload: i\n        });\n      } catch (r) {\n        this.client.logger.error(r);\n      }\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(rt.expired, async n => {\n      const {\n        topic: t,\n        id: e\n      } = At(n.target);\n      if (e && this.client.pendingRequest.keys.includes(e)) return await this.deletePendingSessionRequest(e, l(\"EXPIRED\"), !0);\n      if (e && this.client.auth.requests.keys.includes(e)) return await this.deletePendingAuthRequest(e, l(\"EXPIRED\"), !0);\n      t ? this.client.session.keys.includes(t) && (await this.deleteSession({\n        topic: t,\n        expirerHasDeleted: !0\n      }), this.client.events.emit(\"session_expire\", {\n        topic: t\n      })) : e && (await this.deleteProposal(e, !0), this.client.events.emit(\"proposal_expire\", {\n        id: e\n      }));\n    });\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(ve.create, n => this.onPairingCreated(n)), this.client.core.pairing.events.on(ve.delete, n => {\n      this.addToRecentlyDeleted(n.topic, \"pairing\");\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!V(n, !1)) {\n      const {\n        message: t\n      } = l(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: t\n      } = l(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(t);\n    }\n    if (k(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: t\n      } = l(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(t);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!V(n, !1)) {\n      const {\n        message: t\n      } = l(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(t);\n    }\n    if (this.checkRecentlyDeleted(n), !this.client.session.keys.includes(n)) {\n      const {\n        message: t\n      } = l(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(t);\n    }\n    if (k(this.client.session.get(n).expiry)) {\n      await this.deleteSession({\n        topic: n\n      });\n      const {\n        message: t\n      } = l(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(t);\n    }\n    if (!this.client.core.crypto.keychain.has(n)) {\n      const {\n        message: t\n      } = l(\"MISSING_OR_INVALID\", `session topic does not exist in keychain: ${n}`);\n      throw await this.deleteSession({\n        topic: n\n      }), new Error(t);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.checkRecentlyDeleted(n), this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (V(n, !1)) {\n      const {\n        message: t\n      } = l(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(t);\n    } else {\n      const {\n        message: t\n      } = l(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(t);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!xt(n)) {\n      const {\n        message: t\n      } = l(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(t);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: t\n      } = l(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(t);\n    }\n    if (k(this.client.proposal.get(n).expiryTimestamp)) {\n      await this.deleteProposal(n);\n      const {\n        message: t\n      } = l(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(t);\n    }\n  }\n}\nclass es extends U {\n  constructor(n, t) {\n    super(n, t, Ue, ie), this.core = n, this.logger = t;\n  }\n}\nclass Ze extends U {\n  constructor(n, t) {\n    super(n, t, ke, ie), this.core = n, this.logger = t;\n  }\n}\nclass ts extends U {\n  constructor(n, t) {\n    super(n, t, Fe, ie, e => e.id), this.core = n, this.logger = t;\n  }\n}\nclass ss extends U {\n  constructor(n, t) {\n    super(n, t, Ye, J, () => B), this.core = n, this.logger = t;\n  }\n}\nclass is extends U {\n  constructor(n, t) {\n    super(n, t, Xe, J), this.core = n, this.logger = t;\n  }\n}\nclass rs extends U {\n  constructor(n, t) {\n    super(n, t, Je, J, e => e.id), this.core = n, this.logger = t;\n  }\n}\nclass ns {\n  constructor(n, t) {\n    this.core = n, this.logger = t, this.authKeys = new ss(this.core, this.logger), this.pairingTopics = new is(this.core, this.logger), this.requests = new rs(this.core, this.logger);\n  }\n  async init() {\n    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();\n  }\n}\nclass oe extends pt {\n  constructor(n) {\n    super(n), this.protocol = Ee, this.version = Se, this.name = re.name, this.events = new Ct(), this.on = (e, s) => this.events.on(e, s), this.once = (e, s) => this.events.once(e, s), this.off = (e, s) => this.events.off(e, s), this.removeListener = (e, s) => this.events.removeListener(e, s), this.removeAllListeners = e => this.events.removeAllListeners(e), this.connect = async e => {\n      try {\n        return await this.engine.connect(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.pair = async e => {\n      try {\n        return await this.engine.pair(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approve = async e => {\n      try {\n        return await this.engine.approve(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.reject = async e => {\n      try {\n        return await this.engine.reject(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.update = async e => {\n      try {\n        return await this.engine.update(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.extend = async e => {\n      try {\n        return await this.engine.extend(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.request = async e => {\n      try {\n        return await this.engine.request(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.respond = async e => {\n      try {\n        return await this.engine.respond(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.ping = async e => {\n      try {\n        return await this.engine.ping(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.emit = async e => {\n      try {\n        return await this.engine.emit(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.disconnect = async e => {\n      try {\n        return await this.engine.disconnect(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.find = e => {\n      try {\n        return this.engine.find(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (e) {\n        throw this.logger.error(e.message), e;\n      }\n    }, this.authenticate = async e => {\n      try {\n        return await this.engine.authenticate(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.formatAuthMessage = e => {\n      try {\n        return this.engine.formatAuthMessage(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approveSessionAuthenticate = async e => {\n      try {\n        return await this.engine.approveSessionAuthenticate(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.rejectSessionAuthenticate = async e => {\n      try {\n        return await this.engine.rejectSessionAuthenticate(e);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = n?.name || re.name, this.metadata = n?.metadata || Dt(), this.signConfig = n?.signConfig;\n    const t = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : ot(at({\n      level: n?.logger || re.logger\n    }));\n    this.core = n?.core || new nt(n), this.logger = ct(t, this.name), this.session = new Ze(this.core, this.logger), this.proposal = new es(this.core, this.logger), this.pendingRequest = new ts(this.core, this.logger), this.engine = new Zt(this), this.auth = new ns(this.core, this.logger);\n  }\n  static async init(n) {\n    const t = new oe(n);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return lt(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), await this.auth.init(), this.core.verify.init({\n        verifyUrl: this.metadata.verifyUrl\n      }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst os = Ze,\n  as = oe;\nexport { He as AUTH_CONTEXT, Ye as AUTH_KEYS_CONTEXT, Xe as AUTH_PAIRING_TOPIC_CONTEXT, ze as AUTH_PROTOCOL, B as AUTH_PUBLIC_KEY_NAME, Je as AUTH_REQUEST_CONTEXT, J as AUTH_STORAGE_PREFIX, Ht as AUTH_VERSION, je as ENGINE_CONTEXT, D as ENGINE_QUEUE_STATES, R as ENGINE_RPC_OPTS, Ft as HISTORY_CONTEXT, jt as HISTORY_EVENTS, Qt as HISTORY_STORAGE_VERSION, Qe as METHODS_TO_VERIFY, Ue as PROPOSAL_CONTEXT, zt as PROPOSAL_EXPIRY, Ge as PROPOSAL_EXPIRY_MESSAGE, Fe as REQUEST_CONTEXT, ke as SESSION_CONTEXT, L as SESSION_EXPIRY, ne as SESSION_REQUEST_EXPIRY_BOUNDARIES, _e as SIGN_CLIENT_CONTEXT, re as SIGN_CLIENT_DEFAULT, Gt as SIGN_CLIENT_EVENTS, Ee as SIGN_CLIENT_PROTOCOL, kt as SIGN_CLIENT_STORAGE_OPTIONS, ie as SIGN_CLIENT_STORAGE_PREFIX, Se as SIGN_CLIENT_VERSION, os as SessionStore, as as SignClient, fe as WALLETCONNECT_DEEPLINK_CHOICE, oe as default };","map":{"version":3,"names":[],"sources":["/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/client.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/history.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/proposal.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/session.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/engine.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/pendingRequest.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/verify.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/constants/auth.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/engine.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/proposal.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/session.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/pendingRequest.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/authKey.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/authPairingTopic.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/authRequest.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/controllers/authStore.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/client.ts","/Users/boraoz/Desktop/nft-marketplace/node_modules/@walletconnect/sign-client/src/index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.com\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n  session_authenticate: \"session_authenticate\",\n  session_request_expire: \"session_request_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\nexport const WALLETCONNECT_DEEPLINK_CHOICE = \"WALLETCONNECT_DEEPLINK_CHOICE\";\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, ONE_HOUR, SEVEN_DAYS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1120,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1121,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n  wc_sessionAuthenticate: {\n    req: {\n      ttl: ONE_HOUR,\n      prompt: true,\n      tag: 1116,\n    },\n    res: {\n      ttl: ONE_HOUR,\n      prompt: false,\n      tag: 1117,\n    },\n    reject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1118,\n    },\n    autoReject: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1119,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n\nexport const ENGINE_QUEUE_STATES: { idle: \"IDLE\"; active: \"ACTIVE\" } = {\n  idle: \"IDLE\",\n  active: \"ACTIVE\",\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\n","export const AUTH_PROTOCOL = \"wc\";\nexport const AUTH_VERSION = 1.5;\nexport const AUTH_CONTEXT = \"auth\";\nexport const AUTH_KEYS_CONTEXT = \"authKeys\";\nexport const AUTH_PAIRING_TOPIC_CONTEXT = \"pairingTopics\";\nexport const AUTH_REQUEST_CONTEXT = \"requests\";\n\nexport const AUTH_STORAGE_PREFIX = `${AUTH_PROTOCOL}@${AUTH_VERSION}:${AUTH_CONTEXT}:`;\nexport const AUTH_PUBLIC_KEY_NAME = `${AUTH_STORAGE_PREFIX}:PUB_KEY`;\n","import {\n  EXPIRER_EVENTS,\n  PAIRING_EVENTS,\n  RELAYER_DEFAULT_PROTOCOL,\n  RELAYER_EVENTS,\n  VERIFY_SERVER,\n} from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  payloadId,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  JsonRpcRequest,\n  ErrorResponse,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES, ONE_SECOND, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n  PairingTypes,\n  AuthTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isBrowser,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n  handleDeeplinkRedirect,\n  MemoryStore,\n  getDeepLink,\n  hashKey,\n  getDidAddress,\n  formatMessage,\n  getMethodsFromRecap,\n  buildNamespacesFromAuth,\n  createEncodedRecap,\n  getChainsFromRecap,\n  mergeEncodedRecaps,\n  getRecapFromResources,\n  validateSignedCacao,\n  getNamespacedDidChainId,\n  parseChainId,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n  WALLETCONNECT_DEEPLINK_CHOICE,\n  ENGINE_QUEUE_STATES,\n  AUTH_PUBLIC_KEY_NAME,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n\n  /**\n   * Queue responsible for processing incoming requests such as session_update, session_event, session_ping etc\n   * It's needed when the client receives multiple requests at once from the mailbox immediately after initialization and to avoid attempting to process them all at the same time\n   */\n  private requestQueue: EngineTypes.EngineQueue<EngineTypes.EventCallback<JsonRpcRequest>> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  /**\n   * Queue responsible for processing incoming session_request\n   * The queue emits the next request only after the previous one has been responded to\n   */\n  private sessionRequestQueue: EngineTypes.EngineQueue<PendingRequestTypes.Struct> = {\n    state: ENGINE_QUEUE_STATES.idle,\n    queue: [],\n  };\n\n  private requestQueueDelay = ONE_SECOND;\n\n  private expectedPairingMethodMap: Map<string, string[]> = new Map();\n\n  // Ephemeral (in-memory) map to store recently deleted items\n  private recentlyDeletedMap = new Map<\n    string | number,\n    \"pairing\" | \"session\" | \"proposal\" | \"request\"\n  >();\n\n  private recentlyDeletedLimit = 200;\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.registerPairingEvents();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n      setTimeout(() => {\n        this.sessionRequestQueue.queue = this.getPendingSessionRequests();\n        this.processSessionRequestQueue();\n      }, toMiliseconds(this.requestQueueDelay));\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    await this.isInitialized();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n\n    try {\n      if (topic) {\n        const pairing = this.client.core.pairing.pairings.get(topic);\n        active = pairing.active;\n      }\n    } catch (error) {\n      this.client.logger.error(`connect() -> pairing.get(${topic}) failed`);\n      throw error;\n    }\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n    // safety check to ensure pairing topic is available\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const expiry = ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl || FIVE_MINUTES;\n    const expiryTimestamp = calcExpiry(expiry);\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp,\n      pairingTopic: topic,\n      ...(sessionProperties && { sessionProperties }),\n    };\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(expiry, PROPOSAL_EXPIRY_MESSAGE);\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = {\n            ...session,\n            pairingTopic: proposal.pairingTopic,\n            requiredNamespaces: proposal.requiredNamespaces,\n            optionalNamespaces: proposal.optionalNamespaces,\n          };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic) {\n            await this.client.core.pairing.updateMetadata({\n              topic,\n              metadata: session.peer.metadata,\n            });\n          }\n          this.cleanupDuplicatePairings(completeSession);\n          resolve(completeSession);\n        }\n      },\n    );\n    const id = await this.sendRequest({\n      topic,\n      method: \"wc_sessionPropose\",\n      params: proposal,\n      throwOnFailedPublish: true,\n    });\n    await this.setProposal(id, { id, ...proposal });\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    await this.isInitialized();\n    try {\n      return await this.client.core.pairing.pair(params);\n    } catch (error) {\n      this.client.logger.error(\"pair() failed\");\n      throw error;\n    }\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    await this.isInitialized();\n    try {\n      await this.isValidApprove(params);\n    } catch (error) {\n      this.client.logger.error(\"approve() -> isValidApprove() failed\");\n      throw error;\n    }\n    const { id, relayProtocol, namespaces, sessionProperties, sessionConfig } = params;\n    let proposal;\n    try {\n      proposal = this.client.proposal.get(id);\n    } catch (error) {\n      this.client.logger.error(`approve() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    const { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n      ...(sessionConfig && { sessionConfig }),\n    };\n    await this.client.core.relayer.subscribe(sessionTopic);\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n    };\n    await this.client.session.set(sessionTopic, session);\n    try {\n      await this.sendResult<\"wc_sessionPropose\">({\n        id,\n        topic: pairingTopic,\n        result: {\n          relay: {\n            protocol: relayProtocol ?? \"irn\",\n          },\n          responderPublicKey: selfPublicKey,\n        },\n        throwOnFailedPublish: true,\n      });\n      await this.sendRequest({\n        topic: sessionTopic,\n        method: \"wc_sessionSettle\",\n        params: sessionSettle,\n        throwOnFailedPublish: true,\n      });\n    } catch (error) {\n      this.client.logger.error(error);\n      // if the publish fails, delete the session and throw an error\n      this.client.session.delete(sessionTopic, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.relayer.unsubscribe(sessionTopic);\n      throw error;\n    }\n\n    await this.client.core.pairing.updateMetadata({\n      topic: pairingTopic,\n      metadata: proposer.metadata,\n    });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    await this.client.core.pairing.activate({ topic: pairingTopic });\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () =>\n        new Promise((resolve) =>\n          setTimeout(() => resolve(this.client.session.get(sessionTopic)), 5_00),\n        ), // artificial delay to allow for the session to be processed by the peer\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    await this.isInitialized();\n    try {\n      await this.isValidReject(params);\n    } catch (error) {\n      this.client.logger.error(\"reject() -> isValidReject() failed\");\n      throw error;\n    }\n    const { id, reason } = params;\n    let pairingTopic;\n    try {\n      const proposal = this.client.proposal.get(id);\n      pairingTopic = proposal.pairingTopic;\n    } catch (error) {\n      this.client.logger.error(`reject() -> proposal.get(${id}) failed`);\n      throw error;\n    }\n\n    if (pairingTopic) {\n      await this.sendError({\n        id,\n        topic: pairingTopic,\n        error: reason,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.reject,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    await this.isInitialized();\n    try {\n      await this.isValidUpdate(params);\n    } catch (error) {\n      this.client.logger.error(\"update() -> isValidUpdate() failed\");\n      throw error;\n    }\n    const { topic, namespaces } = params;\n\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n\n    const oldNamespaces = this.client.session.get(topic).namespaces;\n    this.events.once(engineEvent(\"session_update\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else {\n        resolve();\n      }\n    });\n    // Update the session with the new namespaces, if the publish fails, revert to the old.\n    // This allows the client to use the updated session like emitting events\n    // without waiting for the peer to acknowledge\n    await this.client.session.update(topic, { namespaces });\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionUpdate\",\n      params: { namespaces },\n      throwOnFailedPublish: true,\n      clientRpcId,\n      relayRpcId,\n    }).catch((error) => {\n      this.client.logger.error(error);\n      this.client.session.update(topic, { namespaces: oldNamespaces });\n      reject(error);\n    });\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    await this.isInitialized();\n    try {\n      await this.isValidExtend(params);\n    } catch (error) {\n      this.client.logger.error(\"extend() -> isValidExtend() failed\");\n      throw error;\n    }\n\n    const { topic } = params;\n    const clientRpcId = payloadId();\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", clientRpcId), ({ error }: any) => {\n      if (error) reject(error);\n      else resolve();\n    });\n\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n    this.sendRequest({\n      topic,\n      method: \"wc_sessionExtend\",\n      params: {},\n      clientRpcId,\n      throwOnFailedPublish: true,\n    }).catch((e) => {\n      reject(e);\n    });\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    await this.isInitialized();\n    try {\n      await this.isValidRequest(params);\n    } catch (error) {\n      this.client.logger.error(\"request() -> isValidRequest() failed\");\n      throw error;\n    }\n    const { chainId, request, topic, expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl } = params;\n    const session = this.client.session.get(topic);\n    const clientRpcId = payloadId();\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    const { done, resolve, reject } = createDelayedPromise<T>(\n      expiry,\n      \"Request expired. Please try again.\",\n    );\n    this.events.once<\"session_request\">(\n      engineEvent(\"session_request\", clientRpcId),\n      ({ error, result }) => {\n        if (error) reject(error);\n        else resolve(result);\n      },\n    );\n    return await Promise.all([\n      new Promise<void>(async (resolve) => {\n        await this.sendRequest({\n          clientRpcId,\n          relayRpcId,\n          topic,\n          method: \"wc_sessionRequest\",\n          params: {\n            request: {\n              ...request,\n              expiryTimestamp: calcExpiry(expiry),\n            },\n            chainId,\n          },\n          expiry,\n          throwOnFailedPublish: true,\n        }).catch((error) => reject(error));\n        this.client.events.emit(\"session_request_sent\", {\n          topic,\n          request,\n          chainId,\n          id: clientRpcId,\n        });\n        resolve();\n      }),\n      new Promise<void>(async (resolve) => {\n        // only attempt to handle deeplinks if they are not explicitly disabled in the session config\n        if (!session.sessionConfig?.disableDeepLink) {\n          const wcDeepLink = await getDeepLink(\n            this.client.core.storage,\n            WALLETCONNECT_DEEPLINK_CHOICE,\n          );\n          handleDeeplinkRedirect({ id: clientRpcId, topic, wcDeepLink });\n        }\n        resolve();\n      }),\n      done(),\n    ]).then((result) => result[2]); // order is important here, we want to return the result of the `done` promise\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    if (isJsonRpcResult(response)) {\n      await this.sendResult({ id, topic, result: response.result, throwOnFailedPublish: true });\n    } else if (isJsonRpcError(response)) {\n      await this.sendError({ id, topic, error: response.error });\n    }\n    this.cleanupAfterResponse(params);\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    await this.isInitialized();\n    try {\n      await this.isValidPing(params);\n    } catch (error) {\n      this.client.logger.error(\"ping() -> isValidPing() failed\");\n      throw error;\n    }\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const clientRpcId = payloadId();\n      const relayRpcId = getBigIntRpcId().toString() as any;\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", clientRpcId), ({ error }: any) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await Promise.all([\n        this.sendRequest({\n          topic,\n          method: \"wc_sessionPing\",\n          params: {},\n          throwOnFailedPublish: true,\n          clientRpcId,\n          relayRpcId,\n        }),\n        done(),\n      ]);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    const relayRpcId = getBigIntRpcId().toString() as any;\n    await this.sendRequest({\n      topic,\n      method: \"wc_sessionEvent\",\n      params: { event, chainId },\n      throwOnFailedPublish: true,\n      relayRpcId,\n    });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    await this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      // await an ack to ensure the relay has received the disconnect request\n      await this.sendRequest({\n        topic,\n        method: \"wc_sessionDelete\",\n        params: getSdkError(\"USER_DISCONNECTED\"),\n        throwOnFailedPublish: true,\n      });\n      await this.deleteSession({ topic, emitEvent: false });\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.disconnect({ topic });\n    } else {\n      const { message } = getInternalError(\n        \"MISMATCHED_TOPIC\",\n        `Session or pairing topic not found: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Auth ------------------------------------------------ //\n\n  public authenticate: IEngine[\"authenticate\"] = async (params) => {\n    this.isInitialized();\n    this.isValidAuthenticate(params);\n\n    const {\n      chains,\n      statement = \"\",\n      uri,\n      domain,\n      nonce,\n      type,\n      exp,\n      nbf,\n      methods = [],\n      expiry,\n    } = params;\n    // reassign resources to remove reference as the array is modified and might cause side effects\n    const resources = [...(params.resources || [])];\n\n    const { topic: pairingTopic, uri: connectionUri } = await this.client.core.pairing.create({\n      methods: [\"wc_sessionAuthenticate\"],\n    });\n\n    this.client.logger.info({\n      message: \"Generated new pairing\",\n      pairing: { topic: pairingTopic, uri: connectionUri },\n    });\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(publicKey);\n\n    await Promise.all([\n      this.client.auth.authKeys.set(AUTH_PUBLIC_KEY_NAME, { responseTopic, publicKey }),\n      this.client.auth.pairingTopics.set(responseTopic, { topic: responseTopic, pairingTopic }),\n    ]);\n    // Subscribe to response topic\n    await this.client.core.relayer.subscribe(responseTopic);\n\n    this.client.logger.info(`sending request to new pairing topic: ${pairingTopic}`);\n\n    if (methods.length > 0) {\n      const { namespace } = parseChainId(chains[0]);\n      let recap = createEncodedRecap(namespace, \"request\", methods);\n      const existingRecap = getRecapFromResources(resources);\n      if (existingRecap) {\n        // per Recaps spec, recap must occupy the last position in the resources array\n        // using .pop to remove the element given we already checked it's a recap and will replace it\n        const mergedRecap = mergeEncodedRecaps(recap, resources.pop() as string);\n        recap = mergedRecap;\n      }\n      resources.push(recap);\n    }\n\n    // Ensure the expiry is greater than the minimum required for the request - currently 1h\n    const authRequestExpiry =\n      expiry && expiry > ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl\n        ? expiry\n        : ENGINE_RPC_OPTS.wc_sessionAuthenticate.req.ttl;\n\n    const request = {\n      authPayload: {\n        type: type ?? \"caip122\",\n        chains,\n        statement,\n        aud: uri,\n        domain,\n        version: \"1\",\n        nonce,\n        iat: new Date().toISOString(),\n        exp,\n        nbf,\n        resources,\n      },\n      requester: { publicKey, metadata: this.client.metadata },\n      expiryTimestamp: calcExpiry(authRequestExpiry),\n    };\n\n    // ----- build namespaces for fallback session proposal ----- //\n    const namespaces = {\n      eip155: {\n        chains,\n        // request `personal_sign` method by default to allow for fallback siwe\n        methods: [...new Set([\"personal_sign\", ...methods])],\n        events: [\"chainChanged\", \"accountsChanged\"],\n      },\n    };\n\n    const proposal = {\n      requiredNamespaces: {},\n      optionalNamespaces: namespaces,\n      relays: [{ protocol: \"irn\" }],\n      pairingTopic,\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      expiryTimestamp: calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl),\n    };\n\n    const { done, resolve, reject } = createDelayedPromise(authRequestExpiry, \"Request expired\");\n\n    // handle fallback session proposal response\n    const onSessionConnect = async ({ error, session }: any) => {\n      // cleanup listener for authenticate response\n      this.events.off(engineEvent(\"session_request\", id), onAuthenticate);\n      if (error) reject(error);\n      else if (session) {\n        session.self.publicKey = publicKey;\n        await this.client.session.set(session.topic, session);\n        await this.setExpiry(session.topic, session.expiry);\n        if (pairingTopic) {\n          await this.client.core.pairing.updateMetadata({\n            topic: pairingTopic,\n            metadata: session.peer.metadata,\n          });\n        }\n        const sessionObject = this.client.session.get(session.topic);\n        await this.deleteProposal(fallbackId);\n        resolve({\n          session: sessionObject,\n        });\n      }\n    };\n    // handle session authenticate response\n    const onAuthenticate = async (payload: any) => {\n      // delete this auth request on response\n      // we're using payload from the wallet to establish the session so we don't need to keep this around\n      await this.deletePendingAuthRequest(id, { message: \"fulfilled\", code: 0 });\n\n      if (payload.error) {\n        // wallets that do not support wc_sessionAuthenticate will return an error\n        // we should not reject the promise in this case as the fallback session proposal will be used\n        const error = getSdkError(\"WC_METHOD_UNSUPPORTED\", \"wc_sessionAuthenticate\");\n        if (payload.error.code === error.code) return;\n\n        // cleanup listener for fallback response\n        this.events.off(engineEvent(\"session_connect\"), onSessionConnect);\n        return reject(payload.error.message);\n      }\n      // delete fallback proposal on successful authenticate as the proposal will not be responded to\n      await this.deleteProposal(fallbackId);\n      // cleanup listener for fallback response\n      this.events.off(engineEvent(\"session_connect\"), onSessionConnect);\n\n      const {\n        cacaos,\n        responder,\n      }: {\n        cacaos: AuthTypes.SessionAuthenticateResponseParams[\"cacaos\"];\n        responder: AuthTypes.SessionAuthenticateResponseParams[\"responder\"];\n      } = payload.result;\n\n      const approvedMethods: string[] = [];\n      const approvedAccounts: string[] = [];\n      for (const cacao of cacaos) {\n        const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n        if (!isValid) {\n          this.client.logger.error(cacao, \"Signature verification failed\");\n          reject(getSdkError(\"SESSION_SETTLEMENT_FAILED\", \"Signature verification failed\"));\n        }\n\n        const { p: payload } = cacao;\n        const recap = getRecapFromResources(payload.resources);\n\n        const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n        const parsedAddress = getDidAddress(payload.iss) as string;\n\n        if (recap) {\n          const methodsfromRecap = getMethodsFromRecap(recap);\n          const chainsFromRecap = getChainsFromRecap(recap);\n          approvedMethods.push(...methodsfromRecap);\n          approvedChains.push(...chainsFromRecap);\n        }\n\n        for (const chain of approvedChains) {\n          approvedAccounts.push(`${chain}:${parsedAddress}`);\n        }\n      }\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        publicKey,\n        responder.publicKey,\n      );\n\n      //create session object\n      let session: SessionTypes.Struct | undefined;\n\n      if (approvedMethods.length > 0) {\n        session = {\n          topic: sessionTopic,\n          acknowledged: true,\n          self: {\n            publicKey,\n            metadata: this.client.metadata,\n          },\n          peer: responder,\n          controller: responder.publicKey,\n          expiry: calcExpiry(SESSION_EXPIRY),\n          requiredNamespaces: {},\n          optionalNamespaces: {},\n          relay: { protocol: \"irn\" },\n          pairingTopic,\n          namespaces: buildNamespacesFromAuth(\n            [...new Set(approvedMethods)],\n            [...new Set(approvedAccounts)],\n          ),\n        };\n\n        await this.client.core.relayer.subscribe(sessionTopic);\n        await this.client.session.set(sessionTopic, session);\n\n        session = this.client.session.get(sessionTopic);\n      }\n      resolve({\n        auths: cacaos,\n        session,\n      });\n    };\n\n    // set the ids for both requests\n    const id = payloadId();\n    const fallbackId = payloadId();\n\n    // subscribe to response events\n    this.events.once<\"session_connect\">(engineEvent(\"session_connect\"), onSessionConnect);\n    this.events.once(engineEvent(\"session_request\", id), onAuthenticate);\n\n    try {\n      // send both (main & fallback) requests\n      await Promise.all([\n        this.sendRequest({\n          topic: pairingTopic,\n          method: \"wc_sessionAuthenticate\",\n          params: request,\n          expiry: params.expiry,\n          throwOnFailedPublish: true,\n          clientRpcId: id,\n        }),\n        this.sendRequest({\n          topic: pairingTopic,\n          method: \"wc_sessionPropose\",\n          params: proposal,\n          expiry: ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl,\n          throwOnFailedPublish: true,\n          clientRpcId: fallbackId,\n        }),\n      ]);\n    } catch (error) {\n      // cleanup listeners on failed publish\n      this.events.off(engineEvent(\"session_connect\"), onSessionConnect);\n      this.events.off(engineEvent(\"session_request\", id), onAuthenticate);\n      throw error;\n    }\n\n    await this.setProposal(fallbackId, { id: fallbackId, ...proposal });\n    await this.setAuthRequest(id, {\n      request: { ...request, verifyContext: {} as any },\n      pairingTopic,\n    });\n\n    return {\n      uri: connectionUri,\n      response: done,\n    } as EngineTypes.SessionAuthenticateResponsePromise;\n  };\n\n  public approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"] = async (\n    sessionAuthenticateResponseParams,\n  ) => {\n    this.isInitialized();\n\n    const { id, auths } = sessionAuthenticateResponseParams;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    const approvedMethods: string[] = [];\n    const approvedAccounts: string[] = [];\n    for (const cacao of auths) {\n      const isValid = await validateSignedCacao({ cacao, projectId: this.client.core.projectId });\n      if (!isValid) {\n        const invalidErr = getSdkError(\n          \"SESSION_SETTLEMENT_FAILED\",\n          \"Signature verification failed\",\n        );\n\n        await this.sendError({\n          id,\n          topic: responseTopic,\n          error: invalidErr,\n          encodeOpts,\n        });\n\n        throw new Error(invalidErr.message);\n      }\n\n      const { p: payload } = cacao;\n      const recap = getRecapFromResources(payload.resources);\n\n      const approvedChains: string[] = [getNamespacedDidChainId(payload.iss) as string];\n\n      const parsedAddress = getDidAddress(payload.iss) as string;\n\n      if (recap) {\n        const methodsfromRecap = getMethodsFromRecap(recap);\n        const chainsFromRecap = getChainsFromRecap(recap);\n        approvedMethods.push(...methodsfromRecap);\n        approvedChains.push(...chainsFromRecap);\n      }\n      for (const chain of approvedChains) {\n        approvedAccounts.push(`${chain}:${parsedAddress}`);\n      }\n    }\n\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      senderPublicKey,\n      receiverPublicKey,\n    );\n    let session: SessionTypes.Struct | undefined;\n    if (approvedMethods?.length > 0) {\n      session = {\n        topic: sessionTopic,\n        acknowledged: true,\n        self: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: receiverPublicKey,\n          metadata: pendingRequest.requester.metadata,\n        },\n        controller: receiverPublicKey,\n        expiry: calcExpiry(SESSION_EXPIRY),\n        authentication: auths,\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        relay: { protocol: \"irn\" },\n        pairingTopic: \"\",\n        namespaces: buildNamespacesFromAuth(\n          [...new Set(approvedMethods)],\n          [...new Set(approvedAccounts)],\n        ),\n      };\n\n      await this.client.core.relayer.subscribe(sessionTopic);\n      await this.client.session.set(sessionTopic, session);\n    }\n\n    await this.sendResult<\"wc_sessionAuthenticate\">({\n      topic: responseTopic,\n      id,\n      result: {\n        cacaos: auths,\n        responder: {\n          publicKey: senderPublicKey,\n          metadata: this.client.metadata,\n        },\n      },\n      encodeOpts,\n      throwOnFailedPublish: true,\n    });\n    await this.client.auth.requests.delete(id, { message: \"fulfilled\", code: 0 });\n    await this.client.core.pairing.activate({ topic: pendingRequest.pairingTopic });\n    return { session };\n  };\n\n  public rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"] = async (params) => {\n    await this.isInitialized();\n\n    const { id, reason } = params;\n\n    const pendingRequest = this.getPendingAuthRequest(id);\n\n    if (!pendingRequest) {\n      throw new Error(`Could not find pending auth request with id ${id}`);\n    }\n\n    const receiverPublicKey = pendingRequest.requester.publicKey;\n    const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n    const responseTopic = hashKey(receiverPublicKey);\n\n    const encodeOpts = {\n      type: TYPE_1,\n      receiverPublicKey,\n      senderPublicKey,\n    };\n\n    await this.sendError({\n      id,\n      topic: responseTopic,\n      error: reason,\n      encodeOpts,\n      rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.reject,\n    });\n    await this.client.auth.requests.delete(id, { message: \"rejected\", code: 0 });\n    await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n  };\n\n  public formatAuthMessage: IEngine[\"formatAuthMessage\"] = (params) => {\n    this.isInitialized();\n    const { request, iss } = params;\n    return formatMessage(request, iss);\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    // older SDK versions are missing the `pairingTopic` prop thus we need to check for it\n    if (!session.pairingTopic) return;\n\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.peer.metadata.url &&\n          p.topic &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (params) => {\n    const { topic, expirerHasDeleted = false, emitEvent = true, id = 0 } = params;\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n    this.addToRecentlyDeleted(topic, \"session\");\n    if (this.client.core.crypto.keychain.has(self.publicKey)) {\n      await this.client.core.crypto.deleteKeyPair(self.publicKey);\n    }\n    if (this.client.core.crypto.keychain.has(topic)) {\n      await this.client.core.crypto.deleteSymKey(topic);\n    }\n    if (!expirerHasDeleted) this.client.core.expirer.del(topic);\n    // remove any deeplinks from storage after the session is deleted\n    // to avoid navigating to incorrect deeplink later on\n    this.client.core.storage\n      .removeItem(WALLETCONNECT_DEEPLINK_CHOICE)\n      .catch((e) => this.client.logger.warn(e));\n    this.getPendingSessionRequests().forEach((r) => {\n      if (r.topic === topic) {\n        this.deletePendingSessionRequest(r.id, getSdkError(\"USER_DISCONNECTED\"));\n      }\n    });\n    // reset the queue state back to idle if a request for the deleted session is still in the queue\n    if (topic === this.sessionRequestQueue.queue[0]?.topic) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n    }\n    if (emitEvent) this.client.events.emit(\"session_delete\", { id, topic });\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"proposal\");\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n    this.addToRecentlyDeleted(id, \"request\");\n    this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((r) => r.id !== id);\n    if (expirerHasDeleted) {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.client.events.emit(\"session_request_expire\", { id });\n    }\n  };\n\n  private deletePendingAuthRequest: EnginePrivate[\"deletePendingAuthRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.auth.requests.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (!this.client.session.keys.includes(topic)) return;\n    this.client.core.expirer.set(topic, expiry);\n    await this.client.session.update(topic, { expiry });\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    this.client.core.expirer.set(id, calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl));\n    await this.client.proposal.set(id, proposal);\n  };\n\n  private setAuthRequest: EnginePrivate[\"setAuthRequest\"] = async (id, params) => {\n    const { request, pairingTopic } = params;\n    this.client.core.expirer.set(id, request.expiryTimestamp);\n    await this.client.auth.requests.set(id, {\n      authPayload: request.authPayload,\n      requester: request.requester,\n      expiryTimestamp: request.expiryTimestamp,\n      id,\n      pairingTopic,\n      verifyContext: request.verifyContext,\n    });\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const { id, topic, params, verifyContext } = pendingRequest;\n    const expiry =\n      params.request.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl);\n    this.client.core.expirer.set(id, expiry);\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n      verifyContext,\n    });\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (args) => {\n    const { topic, method, params, expiry, relayRpcId, clientRpcId, throwOnFailedPublish } = args;\n    const payload = formatJsonRpcRequest(method, params, clientRpcId);\n    if (isBrowser() && METHODS_TO_VERIFY.includes(method)) {\n      const hash = hashMessage(JSON.stringify(payload));\n      this.client.core.verify.register({ attestationId: hash });\n    }\n    let message;\n    try {\n      message = await this.client.core.crypto.encode(topic, payload);\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    const opts = ENGINE_RPC_OPTS[method].req;\n    if (expiry) opts.ttl = expiry;\n    if (relayRpcId) opts.id = relayRpcId;\n    this.client.core.history.set(topic, payload);\n    if (throwOnFailedPublish) {\n      opts.internal = {\n        ...opts.internal,\n        throwOnFailedPublish: true,\n      };\n      await this.client.core.relayer.publish(topic, message, opts);\n    } else {\n      this.client.core.relayer\n        .publish(topic, message, opts)\n        .catch((error) => this.client.logger.error(error));\n    }\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (args) => {\n    const { id, topic, result, throwOnFailedPublish, encodeOpts } = args;\n    const payload = formatJsonRpcResult(id, result);\n    let message;\n    try {\n      message = await this.client.core.crypto.encode(topic, payload, encodeOpts);\n    } catch (error) {\n      // if encoding fails e.g. due to missing keychain, we want to cleanup all related data as its unusable\n      await this.cleanup();\n      this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendResult() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    if (throwOnFailedPublish) {\n      opts.internal = {\n        ...opts.internal,\n        throwOnFailedPublish: true,\n      };\n      await this.client.core.relayer.publish(topic, message, opts);\n    } else {\n      this.client.core.relayer\n        .publish(topic, message, opts)\n        .catch((error) => this.client.logger.error(error));\n    }\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (params) => {\n    const { id, topic, error, encodeOpts, rpcOpts } = params;\n    const payload = formatJsonRpcError(id, error);\n    let message;\n    try {\n      message = await this.client.core.crypto.encode(topic, payload, encodeOpts);\n    } catch (error) {\n      await this.cleanup();\n      this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${topic} failed`);\n      throw error;\n    }\n    let record;\n    try {\n      record = await this.client.core.history.get(topic, id);\n    } catch (error) {\n      this.client.logger.error(`sendError() -> history.get(${topic}, ${id}) failed`);\n      throw error;\n    }\n    const opts = rpcOpts || ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      let toCleanup = false;\n      if (isExpired(session.expiry)) toCleanup = true;\n      if (!this.client.core.crypto.keychain.has(session.topic)) toCleanup = true;\n      if (toCleanup) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiryTimestamp)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession({ topic })),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private async isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n    await this.client.core.relayer.confirmOnlineStateOrThrow();\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n\n        // Retrieve the public key (if defined) to decrypt possible `auth_request` response\n        const { publicKey } = this.client.auth.authKeys.keys.includes(AUTH_PUBLIC_KEY_NAME)\n          ? this.client.auth.authKeys.get(AUTH_PUBLIC_KEY_NAME)\n          : ({ responseTopic: undefined, publicKey: undefined } as any);\n\n        const payload = await this.client.core.crypto.decode(topic, message, {\n          receiverPublicKey: publicKey,\n        });\n\n        try {\n          if (isJsonRpcRequest(payload)) {\n            this.client.core.history.set(topic, payload);\n            this.onRelayEventRequest({ topic, payload });\n          } else if (isJsonRpcResponse(payload)) {\n            await this.client.core.history.resolve(payload);\n            await this.onRelayEventResponse({ topic, payload });\n            this.client.core.history.delete(topic, payload.id);\n          } else {\n            this.onRelayEventUnknownPayload({ topic, payload });\n          }\n        } catch (error) {\n          this.client.logger.error(error);\n        }\n      },\n    );\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = async (event) => {\n    this.requestQueue.queue.push(event);\n    await this.processRequestsQueue();\n  };\n\n  private processRequestsQueue = async () => {\n    if (this.requestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(`Request queue already active, skipping...`);\n      return;\n    }\n\n    this.client.logger.info(\n      `Request queue starting with ${this.requestQueue.queue.length} requests`,\n    );\n\n    while (this.requestQueue.queue.length > 0) {\n      this.requestQueue.state = ENGINE_QUEUE_STATES.active;\n      const request = this.requestQueue.queue.shift();\n      if (!request) continue;\n\n      try {\n        this.processRequest(request);\n        // small delay to allow for any async tasks to complete\n        await new Promise((resolve) => setTimeout(resolve, 300));\n      } catch (error) {\n        this.client.logger.warn(error);\n      }\n    }\n    this.requestQueue.state = ENGINE_QUEUE_STATES.idle;\n  };\n\n  private processRequest: EnginePrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    if (this.shouldIgnorePairingRequest({ topic, requestMethod: reqMethod })) {\n      return;\n    }\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeRequest(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequest(topic, payload);\n      case \"wc_sessionEvent\":\n        return this.onSessionEventRequest(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      case \"wc_sessionAuthenticate\":\n        return this.onSessionAuthenticateResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  private onRelayEventUnknownPayload: EnginePrivate[\"onRelayEventUnknownPayload\"] = (event) => {\n    const { topic } = event;\n    const { message } = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `Decoded payload on topic ${topic} is not identifiable as a JSON-RPC request or a response.`,\n    );\n    throw new Error(message);\n  };\n\n  private shouldIgnorePairingRequest: EnginePrivate[\"shouldIgnorePairingRequest\"] = (params) => {\n    const { topic, requestMethod } = params;\n    const expectedMethods = this.expectedPairingMethodMap.get(topic);\n    // check if the request method matches the expected method\n    if (!expectedMethods) return false;\n    if (expectedMethods.includes(requestMethod)) return false;\n\n    /**\n     * we want to make sure fallback session proposal is ignored only if there are subscribers\n     * for the `session_authenticate` event, otherwise this would result in no-op for the user\n     */\n    if (expectedMethods.includes(\"wc_sessionAuthenticate\")) {\n      if (this.client.events.listenerCount(\"session_authenticate\") > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidConnect({ ...payload.params });\n      const expiryTimestamp =\n        params.expiryTimestamp || calcExpiry(ENGINE_RPC_OPTS.wc_sessionPropose.req.ttl);\n      const proposal = { id, pairingTopic: topic, expiryTimestamp, ...params };\n      await this.setProposal(id, proposal);\n      const hash = hashMessage(JSON.stringify(payload));\n      const verifyContext = await this.getVerifyContext(hash, proposal.proposer.metadata);\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionPropose.autoReject,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic);\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      const target = engineEvent(\"session_connect\");\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners, 954`);\n      }\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const { relay, controller, expiry, namespaces, sessionProperties, sessionConfig } =\n        payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic: \"\", // pairingTopic will be set in the `session_connect` handler\n        requiredNamespaces: {},\n        optionalNamespaces: {},\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n        ...(sessionConfig && { sessionConfig }),\n      };\n      await this.sendResult<\"wc_sessionSettle\">({\n        id: payload.id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      const target = engineEvent(\"session_connect\");\n      const listeners = this.events.listenerCount(target);\n      if (listeners === 0) {\n        throw new Error(`emitting ${target} without any listeners 997`);\n      }\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      const memoryKey = `${topic}_session_update`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        this.sendError({ id, topic, error: getSdkError(\"INVALID_UPDATE_REQUEST\") });\n        return;\n      }\n      this.isValidUpdate({ topic, ...params });\n      try {\n        MemoryStore.set(memoryKey, id);\n        await this.client.session.update(topic, { namespaces: params.namespaces });\n        await this.sendResult<\"wc_sessionUpdate\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        });\n      } catch (e) {\n        MemoryStore.delete(memoryKey);\n        throw e;\n      }\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  // compares the timestamp of the last processed request with the current request\n  // client <-> client rpc ID is timestamp + 3 random digits\n  private isRequestOutOfSync = (lastId: number, currentId: number) => {\n    return parseInt(currentId.toString().slice(0, -3)) <= parseInt(lastId.toString().slice(0, -3));\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_update\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_extend\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">({\n        id,\n        topic,\n        result: true,\n        throwOnFailedPublish: true,\n      });\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_ping\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession({ topic, id }));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">({\n          id,\n          topic,\n          result: true,\n          throwOnFailedPublish: true,\n        }),\n        this.cleanupPendingSentRequestsForTopic({ topic, error: getSdkError(\"USER_DISCONNECTED\") }),\n      ]);\n    } catch (err: any) {\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (topic, payload) => {\n    const { id, params } = payload;\n    try {\n      await this.isValidRequest({ topic, ...params });\n      const hash = hashMessage(\n        JSON.stringify(formatJsonRpcRequest(\"wc_sessionRequest\", params, id)),\n      );\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext(hash, session.peer.metadata);\n      const request = {\n        id,\n        topic,\n        params,\n        verifyContext,\n      };\n      await this.setPendingSessionRequest(request);\n      if (this.client.signConfig?.disableRequestQueue) {\n        this.emitSessionRequest(request);\n      } else {\n        this.addSessionRequestToSessionRequestQueue(request);\n        this.processSessionRequestQueue();\n      }\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    const target = engineEvent(\"session_request\", id);\n    const listeners = this.events.listenerCount(target);\n    if (listeners === 0) {\n      throw new Error(`emitting ${target} without any listeners`);\n    }\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      // similar to session update, we want to discard out of sync requests\n      // additionally we have to check the event type as well e.g. chainChanged/accountsChanged\n      const memoryKey = `${topic}_session_event_${params.event.name}`;\n      // compare the current request id with the last processed session update\n      // we want to update only if the request is newer than the last processed one\n      const lastSessionUpdateId = MemoryStore.get<number>(memoryKey);\n      if (lastSessionUpdateId && this.isRequestOutOfSync(lastSessionUpdateId, id)) {\n        this.client.logger.info(`Discarding out of sync request - ${id}`);\n        return;\n      }\n\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n      MemoryStore.set(memoryKey, id);\n    } catch (err: any) {\n      await this.sendError({\n        id,\n        topic,\n        error: err,\n      });\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionAuthenticateResponse: EnginePrivate[\"onSessionAuthenticateResponse\"] = (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    this.client.logger.trace({\n      type: \"method\",\n      method: \"onSessionAuthenticateResponse\",\n      topic,\n      payload,\n    });\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionAuthenticateRequest: EnginePrivate[\"onSessionAuthenticateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    try {\n      const { requester, authPayload, expiryTimestamp } = payload.params;\n      const hash = hashMessage(JSON.stringify(payload));\n      const verifyContext = await this.getVerifyContext(hash, this.client.metadata);\n      const pendingRequest = {\n        requester,\n        pairingTopic: topic,\n        id: payload.id,\n        authPayload,\n        verifyContext,\n        expiryTimestamp,\n      };\n      await this.setAuthRequest(payload.id, { request: pendingRequest, pairingTopic: topic });\n      this.client.events.emit(\"session_authenticate\", {\n        topic,\n        params: payload.params,\n        id: payload.id,\n      });\n    } catch (err: any) {\n      this.client.logger.error(err);\n\n      const receiverPublicKey = payload.params.requester.publicKey;\n      const senderPublicKey = await this.client.core.crypto.generateKeyPair();\n\n      const encodeOpts = {\n        type: TYPE_1,\n        receiverPublicKey,\n        senderPublicKey,\n      };\n      await this.sendError({\n        id: payload.id,\n        topic,\n        error: err,\n        encodeOpts,\n        rpcOpts: ENGINE_RPC_OPTS.wc_sessionAuthenticate.autoReject,\n      });\n    }\n  };\n\n  private addSessionRequestToSessionRequestQueue = (request: PendingRequestTypes.Struct) => {\n    this.sessionRequestQueue.queue.push(request);\n  };\n\n  private cleanupAfterResponse = (params: EngineTypes.RespondParams) => {\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n    // intentionally delay the emitting of the next pending request a bit\n    setTimeout(() => {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.idle;\n      this.processSessionRequestQueue();\n    }, toMiliseconds(this.requestQueueDelay));\n  };\n\n  // Allows for cleanup on any sent pending requests if the peer disconnects the session before responding\n  private cleanupPendingSentRequestsForTopic = ({\n    topic,\n    error,\n  }: {\n    topic: string;\n    error: ErrorResponse;\n  }) => {\n    const pendingRequests = this.client.core.history.pending;\n    if (pendingRequests.length > 0) {\n      const forSession = pendingRequests.filter(\n        (r) => r.topic === topic && r.request.method === \"wc_sessionRequest\",\n      );\n      forSession.forEach((r) => {\n        const id = r.request.id;\n        const target = engineEvent(\"session_request\", id);\n        const listeners = this.events.listenerCount(target);\n        if (listeners === 0) {\n          throw new Error(`emitting ${target} without any listeners`);\n        }\n        // notify .request() handler of the rejection\n        this.events.emit(engineEvent(\"session_request\", r.request.id), {\n          error,\n        });\n      });\n    }\n  };\n\n  private processSessionRequestQueue = () => {\n    if (this.sessionRequestQueue.state === ENGINE_QUEUE_STATES.active) {\n      this.client.logger.info(\"session request queue is already active.\");\n      return;\n    }\n    // Select the first/oldest request in the array to ensure last-in-first-out (LIFO)\n    const request = this.sessionRequestQueue.queue[0];\n    if (!request) {\n      this.client.logger.info(\"session request queue is empty.\");\n      return;\n    }\n\n    try {\n      this.sessionRequestQueue.state = ENGINE_QUEUE_STATES.active;\n      this.emitSessionRequest(request);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private emitSessionRequest = (request: PendingRequestTypes.Struct) => {\n    this.client.events.emit(\"session_request\", request);\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n      if (id && this.client.auth.requests.keys.includes(id)) {\n        return await this.deletePendingAuthRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession({ topic, expirerHasDeleted: true });\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Pairing Events ---------------------------------------- //\n  private registerPairingEvents() {\n    this.client.core.pairing.events.on(PAIRING_EVENTS.create, (pairing: PairingTypes.Struct) =>\n      this.onPairingCreated(pairing),\n    );\n    this.client.core.pairing.events.on(PAIRING_EVENTS.delete, (pairing: PairingTypes.Struct) => {\n      this.addToRecentlyDeleted(pairing.topic, \"pairing\");\n    });\n  }\n\n  /**\n   * when a pairing is created, we check if there is a pending proposal for it.\n   * if there is, we send it to onSessionProposeRequest to be processed as if it was received from the relay.\n   * It allows QR/URI to be scanned multiple times without having to create new pairing.\n   */\n  private onPairingCreated = (pairing: PairingTypes.Struct) => {\n    if (pairing.methods) {\n      this.expectedPairingMethodMap.set(pairing.topic, pairing.methods);\n    }\n    if (pairing.active) return;\n    const proposals = this.client.proposal.getAll();\n    const proposal = proposals.find((p) => p.pairingTopic === pairing.topic);\n    if (!proposal) return;\n    this.onSessionProposeRequest(\n      pairing.topic,\n      formatJsonRpcRequest(\n        \"wc_sessionPropose\",\n        {\n          requiredNamespaces: proposal.requiredNamespaces,\n          optionalNamespaces: proposal.optionalNamespaces,\n          relays: proposal.relays,\n          proposer: proposal.proposer,\n          sessionProperties: proposal.sessionProperties,\n        },\n        proposal.id,\n      ),\n    );\n  };\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    // Store will throw custom message if topic was recently deleted\n    this.checkRecentlyDeleted(topic);\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession({ topic });\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    if (!this.client.core.crypto.keychain.has(topic)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic does not exist in keychain: ${topic}`,\n      );\n      await this.deleteSession({ topic });\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    this.checkRecentlyDeleted(topic);\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiryTimestamp)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties } = params;\n\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    this.checkRecentlyDeleted(id);\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    this.checkRecentlyDeleted(topic);\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    try {\n      // if the session is already disconnected, we can't respond to the request so we need to delete it\n      await this.isValidSessionTopic(topic);\n    } catch (error) {\n      if (params?.response?.id) this.cleanupAfterResponse(params);\n      throw error;\n    }\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidAuthenticate = (params: AuthTypes.SessionAuthenticateParams) => {\n    const { chains, uri, domain, nonce } = params;\n\n    // ----- validate params ----- //\n    if (!Array.isArray(chains) || chains.length === 0) {\n      throw new Error(\"chains is required and must be a non-empty array\");\n    }\n    if (!isValidString(uri, false)) {\n      throw new Error(\"uri is required parameter\");\n    }\n    if (!isValidString(domain, false)) {\n      throw new Error(\"domain is required parameter\");\n    }\n    if (!isValidString(nonce, false)) {\n      throw new Error(\"nonce is required parameter\");\n    }\n\n    // ----- reject multi namespaces ----- //\n    const uniqueNamespaces = [...new Set(chains.map((chain) => parseChainId(chain).namespace))];\n    if (uniqueNamespaces.length > 1) {\n      throw new Error(\n        \"Multi-namespace requests are not supported. Please request single namespace only.\",\n      );\n    }\n\n    const { namespace } = parseChainId(chains[0]);\n    if (namespace !== \"eip155\") {\n      throw new Error(\n        \"Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.\",\n      );\n    }\n  };\n\n  private getVerifyContext = async (hash: string, metadata: CoreTypes.Metadata) => {\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || VERIFY_SERVER,\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      const result = await this.client.core.verify.resolve({\n        attestationId: hash,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (result) {\n        context.verified.origin = result.origin;\n        context.verified.isScam = result.isScam;\n        context.verified.validation =\n          result.origin === new URL(metadata.url).origin ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.info(e);\n    }\n\n    this.client.logger.info(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: ProposalTypes.SessionProperties, type: string) => {\n    Object.values(properties).forEach((property) => {\n      if (!isValidString(property, false)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must be in Record<string, string> format. Received: ${JSON.stringify(property)}`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n\n  private getPendingAuthRequest = (id: number) => {\n    const request = this.client.auth.requests.get(id);\n    return typeof request === \"object\" ? request : undefined;\n  };\n\n  private addToRecentlyDeleted = (\n    id: string | number,\n    type: \"pairing\" | \"session\" | \"proposal\" | \"request\",\n  ) => {\n    this.recentlyDeletedMap.set(id, type);\n    // remove first half of the map if it exceeds the limit\n    if (this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {\n      let i = 0;\n      const numItemsToDelete = this.recentlyDeletedLimit / 2;\n      for (const k of this.recentlyDeletedMap.keys()) {\n        if (i++ >= numItemsToDelete) {\n          break;\n        }\n        this.recentlyDeletedMap.delete(k);\n      }\n    }\n  };\n\n  private checkRecentlyDeleted = (id: string | number) => {\n    const deletedRecord = this.recentlyDeletedMap.get(id);\n    if (deletedRecord) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `Record was recently deleted - ${deletedRecord}: ${id}`,\n      );\n      throw new Error(message);\n    }\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, AUTH_PUBLIC_KEY_NAME } from \"../constants\";\n\nexport class AuthKey extends Store<string, { responseTopic: string; publicKey: string }> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, AUTH_KEYS_CONTEXT, AUTH_STORAGE_PREFIX, () => AUTH_PUBLIC_KEY_NAME);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"@walletconnect/types\";\n\nimport { AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX } from \"../constants\";\n\nexport class AuthPairingTopic extends Store<string, { topic: string; pairingTopic: string }> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, AUTH_PAIRING_TOPIC_CONTEXT, AUTH_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { AuthTypes, ICore } from \"@walletconnect/types\";\n\nimport { AUTH_STORAGE_PREFIX, AUTH_REQUEST_CONTEXT } from \"../constants\";\n\nexport class AuthRequest extends Store<number, AuthTypes.PendingRequest> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      AUTH_REQUEST_CONTEXT,\n      AUTH_STORAGE_PREFIX,\n      (val: AuthTypes.PendingRequest) => val.id,\n    );\n  }\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IAuth, ICore } from \"@walletconnect/types\";\nimport { AuthPairingTopic } from \"./authPairingTopic\";\nimport { AuthRequest } from \"./authRequest\";\nimport { AuthKey } from \"./authKey\";\n\nexport class AuthStore {\n  public authKeys: IAuth[\"authKeys\"];\n  public pairingTopics: IAuth[\"pairingTopics\"];\n  public requests: IAuth[\"requests\"];\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.authKeys = new AuthKey(this.core, this.logger);\n    this.pairingTopics = new AuthPairingTopic(this.core, this.logger);\n    this.requests = new AuthRequest(this.core, this.logger);\n  }\n\n  public async init() {\n    await this.authKeys.init();\n    await this.pairingTopics.init();\n    await this.requests.init();\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { AuthStore, Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n  public auth: ISignClient[\"auth\"];\n  public signConfig?: ISignClient[\"signConfig\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n    this.signConfig = opts?.signConfig;\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n    this.auth = new AuthStore(this.core, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public authenticate: ISignClient[\"authenticate\"] = async (params) => {\n    try {\n      return await this.engine.authenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public formatAuthMessage: ISignClient[\"formatAuthMessage\"] = (params) => {\n    try {\n      return this.engine.formatAuthMessage(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approveSessionAuthenticate: ISignClient[\"approveSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.approveSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public rejectSessionAuthenticate: ISignClient[\"rejectSessionAuthenticate\"] = async (params) => {\n    try {\n      return await this.engine.rejectSessionAuthenticate(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.engine.init();\n      await this.auth.init();\n      this.core.verify.init({ verifyUrl: this.metadata.verifyUrl });\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\nimport { Session } from \"./controllers/session\";\nexport * from \"./constants\";\n\nexport const SessionStore = Session;\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}