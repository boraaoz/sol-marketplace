{"ast":null,"code":"import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, d as deserializeRaw, s as stringify, c as serializeRaw, j as joinKeys } from './shared/unstorage.8581f561.mjs';\nexport { p as prefixStorage } from './shared/unstorage.8581f561.mjs';\nfunction defineDriver(factory) {\n  return factory;\n}\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */new Map();\n  return {\n    name: DRIVER_NAME,\n    options: {},\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return Array.from(data.keys());\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\nfunction createStorage(options = {}) {\n  const context = {\n    mounts: {\n      \"\": options.driver || memory()\n    },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = key => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(mountpoint => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)).map(mountpoint => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(context.mounts[mountpoint], onChange, mountpoint);\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */new Map();\n    const getBatch = mount => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : {\n        ...commonOptions,\n        ...item.options\n      };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map(batch => cb(batch))).then(r => r.flat());\n  };\n  const storage = {\n    // Item\n    hasItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(value => destr(value));\n    },\n    getItems(items, commonOptions) {\n      return runBatch(items, commonOptions, batch => {\n        if (batch.driver.getItems) {\n          return asyncCall(batch.driver.getItems, batch.items.map(item => ({\n            key: item.relativeKey,\n            options: item.options\n          })), commonOptions).then(r => r.map(item => ({\n            key: joinKeys(batch.base, item.key),\n            value: destr(item.value)\n          })));\n        }\n        return Promise.all(batch.items.map(item => {\n          return asyncCall(batch.driver.getItem, item.relativeKey, item.options).then(value => ({\n            key: item.key,\n            value: destr(value)\n          }));\n        }));\n      });\n    },\n    getItemRaw(key, opts = {}) {\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(value => deserializeRaw(value));\n    },\n    async setItem(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async batch => {\n        if (batch.driver.setItems) {\n          return asyncCall(batch.driver.setItems, batch.items.map(item => ({\n            key: item.relativeKey,\n            value: stringify(item.value),\n            options: item.options\n          })), commonOptions);\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(batch.items.map(item => {\n          return asyncCall(batch.driver.setItem, item.relativeKey, stringify(item.value), item.options);\n        }));\n      });\n    },\n    async setItemRaw(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = {\n          removeMeta: opts\n        };\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = {\n          nativeOnly: opts\n        };\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      const meta = /* @__PURE__ */Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(driver.getItem, relativeKey + \"$\", opts).then(value_ => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value, opts = {}) {\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key, opts = {}) {\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      for (const mount of mounts) {\n        const rawKeys = await asyncCall(mount.driver.getKeys, mount.relativeBase, opts);\n        const keys = rawKeys.map(key => mount.mountpoint + normalizeKey(key)).filter(key => !maskedMounts.some(p => key.startsWith(p)));\n        allKeys.push(...keys);\n        maskedMounts = [mount.mountpoint, ...maskedMounts.filter(p => !p.startsWith(mount.mountpoint))];\n      }\n      return base ? allKeys.filter(key => key.startsWith(base) && !key.endsWith(\"$\")) : allKeys.filter(key => !key.endsWith(\"$\"));\n    },\n    // Utils\n    async clear(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      await Promise.all(getMounts(base, false).map(async m => {\n        if (m.driver.clear) {\n          return asyncCall(m.driver.clear, m.relativeBase, opts);\n        }\n        if (m.driver.removeItem) {\n          const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n          return Promise.all(keys.map(key => m.driver.removeItem(key, opts)));\n        }\n      }));\n    },\n    async dispose() {\n      await Promise.all(Object.values(context.mounts).map(driver => dispose(driver)));\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(listener => listener !== callback);\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then(unwatcher => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base, _dispose = true) {\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter(key => key !== base);\n      delete context.mounts[base];\n    },\n    getMount(key = \"\") {\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts(base = \"\", opts = {}) {\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map(m => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    }\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(keys.map(async key => {\n    snapshot2[key.slice(base.length)] = await storage.getItem(key);\n  }));\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2, base = \"\") {\n  base = normalizeBaseKey(base);\n  await Promise.all(Object.entries(snapshot2).map(e => driver.setItem(base + e[0], e[1])));\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {};\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\nconst builtinDrivers = {\n  azureAppConfiguration: \"unstorage/drivers/azure-app-configuration\",\n  azureCosmos: \"unstorage/drivers/azure-cosmos\",\n  azureKeyVault: \"unstorage/drivers/azure-key-vault\",\n  azureStorageBlob: \"unstorage/drivers/azure-storage-blob\",\n  azureStorageTable: \"unstorage/drivers/azure-storage-table\",\n  cloudflareKVBinding: \"unstorage/drivers/cloudflare-kv-binding\",\n  cloudflareKVHTTP: \"unstorage/drivers/cloudflare-kv-http\",\n  cloudflareR2Binding: \"unstorage/drivers/cloudflare-r2-binding\",\n  fs: \"unstorage/drivers/fs\",\n  fsLite: \"unstorage/drivers/fs-lite\",\n  github: \"unstorage/drivers/github\",\n  http: \"unstorage/drivers/http\",\n  indexedb: \"unstorage/drivers/indexedb\",\n  localStorage: \"unstorage/drivers/localstorage\",\n  lruCache: \"unstorage/drivers/lru-cache\",\n  memory: \"unstorage/drivers/memory\",\n  mongodb: \"unstorage/drivers/mongodb\",\n  netlifyBlobs: \"unstorage/drivers/netlify-blobs\",\n  overlay: \"unstorage/drivers/overlay\",\n  planetscale: \"unstorage/drivers/planetscale\",\n  redis: \"unstorage/drivers/redis\",\n  sessionStorage: \"unstorage/drivers/session-storage\",\n  vercelKV: \"unstorage/drivers/vercel-kv\",\n  /** @deprecated */\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  /** @deprecated */\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\"\n};\nexport { builtinDrivers, createStorage, defineDriver, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };","map":{"version":3,"names":["destr","n","normalizeBaseKey","a","normalizeKey","b","asyncCall","d","deserializeRaw","s","stringify","c","serializeRaw","j","joinKeys","p","prefixStorage","defineDriver","factory","DRIVER_NAME","memory","data","Map","name","options","hasItem","key","has","getItem","get","getItemRaw","setItem","value","set","setItemRaw","removeItem","delete","getKeys","Array","from","keys","clear","dispose","createStorage","context","mounts","driver","mountpoints","watching","watchListeners","unwatch","getMount","base","startsWith","relativeKey","slice","length","getMounts","includeParent","filter","mountpoint","map","relativeBase","onChange","event","listener","startWatch","watch","stopWatch","runBatch","items","commonOptions","cb","batches","getBatch","mount","batch","item","isStringItem","options2","push","Promise","all","values","then","r","flat","storage","opts","getItems","setItems","removeMeta","removeMata","getMeta","nativeOnly","meta","Object","create","assign","value_","atime","Date","mtime","setMeta","maskedMounts","allKeys","rawKeys","some","endsWith","m","callback","Error","sort","resolve","unwatcher","catch","console","error","unmount","_dispose","parents","snapshot","snapshot2","restoreSnapshot","entries","e","builtinDrivers","azureAppConfiguration","azureCosmos","azureKeyVault","azureStorageBlob","azureStorageTable","cloudflareKVBinding","cloudflareKVHTTP","cloudflareR2Binding","fs","fsLite","github","http","indexedb","localStorage","lruCache","mongodb","netlifyBlobs","overlay","planetscale","redis","sessionStorage","vercelKV"],"sources":["/Users/boraoz/Desktop/nft-marketplace/node_modules/unstorage/dist/index.mjs"],"sourcesContent":["import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, d as deserializeRaw, s as stringify, c as serializeRaw, j as joinKeys } from './shared/unstorage.8581f561.mjs';\nexport { p as prefixStorage } from './shared/unstorage.8581f561.mjs';\n\nfunction defineDriver(factory) {\n  return factory;\n}\n\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */ new Map();\n  return {\n    name: DRIVER_NAME,\n    options: {},\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return Array.from(data.keys());\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\n\nfunction createStorage(options = {}) {\n  const context = {\n    mounts: { \"\": options.driver || memory() },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = (key) => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(\n      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)\n    ).map((mountpoint) => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(\n        context.mounts[mountpoint],\n        onChange,\n        mountpoint\n      );\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */ new Map();\n    const getBatch = (mount) => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(\n      (r) => r.flat()\n    );\n  };\n  const storage = {\n    // Item\n    hasItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => destr(value)\n      );\n    },\n    getItems(items, commonOptions) {\n      return runBatch(items, commonOptions, (batch) => {\n        if (batch.driver.getItems) {\n          return asyncCall(\n            batch.driver.getItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              options: item.options\n            })),\n            commonOptions\n          ).then(\n            (r) => r.map((item) => ({\n              key: joinKeys(batch.base, item.key),\n              value: destr(item.value)\n            }))\n          );\n        }\n        return Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.getItem,\n              item.relativeKey,\n              item.options\n            ).then((value) => ({\n              key: item.key,\n              value: destr(value)\n            }));\n          })\n        );\n      });\n    },\n    getItemRaw(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => deserializeRaw(value)\n      );\n    },\n    async setItem(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async (batch) => {\n        if (batch.driver.setItems) {\n          return asyncCall(\n            batch.driver.setItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              value: stringify(item.value),\n              options: item.options\n            })),\n            commonOptions\n          );\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.setItem,\n              item.relativeKey,\n              stringify(item.value),\n              item.options\n            );\n          })\n        );\n      });\n    },\n    async setItemRaw(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { removeMeta: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { nativeOnly: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      const meta = /* @__PURE__ */ Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(\n          driver.getItem,\n          relativeKey + \"$\",\n          opts\n        ).then((value_) => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value, opts = {}) {\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key, opts = {}) {\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      for (const mount of mounts) {\n        const rawKeys = await asyncCall(\n          mount.driver.getKeys,\n          mount.relativeBase,\n          opts\n        );\n        const keys = rawKeys.map((key) => mount.mountpoint + normalizeKey(key)).filter((key) => !maskedMounts.some((p) => key.startsWith(p)));\n        allKeys.push(...keys);\n        maskedMounts = [\n          mount.mountpoint,\n          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))\n        ];\n      }\n      return base ? allKeys.filter((key) => key.startsWith(base) && !key.endsWith(\"$\")) : allKeys.filter((key) => !key.endsWith(\"$\"));\n    },\n    // Utils\n    async clear(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      await Promise.all(\n        getMounts(base, false).map(async (m) => {\n          if (m.driver.clear) {\n            return asyncCall(m.driver.clear, m.relativeBase, opts);\n          }\n          if (m.driver.removeItem) {\n            const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n            return Promise.all(\n              keys.map((key) => m.driver.removeItem(key, opts))\n            );\n          }\n        })\n      );\n    },\n    async dispose() {\n      await Promise.all(\n        Object.values(context.mounts).map((driver) => dispose(driver))\n      );\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(\n          (listener) => listener !== callback\n        );\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base, _dispose = true) {\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter((key) => key !== base);\n      delete context.mounts[base];\n    },\n    getMount(key = \"\") {\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts(base = \"\", opts = {}) {\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map((m) => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    }\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(\n    keys.map(async (key) => {\n      snapshot2[key.slice(base.length)] = await storage.getItem(key);\n    })\n  );\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2, base = \"\") {\n  base = normalizeBaseKey(base);\n  await Promise.all(\n    Object.entries(snapshot2).map((e) => driver.setItem(base + e[0], e[1]))\n  );\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {\n  };\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\n\nconst builtinDrivers = {\n  azureAppConfiguration: \"unstorage/drivers/azure-app-configuration\",\n  azureCosmos: \"unstorage/drivers/azure-cosmos\",\n  azureKeyVault: \"unstorage/drivers/azure-key-vault\",\n  azureStorageBlob: \"unstorage/drivers/azure-storage-blob\",\n  azureStorageTable: \"unstorage/drivers/azure-storage-table\",\n  cloudflareKVBinding: \"unstorage/drivers/cloudflare-kv-binding\",\n  cloudflareKVHTTP: \"unstorage/drivers/cloudflare-kv-http\",\n  cloudflareR2Binding: \"unstorage/drivers/cloudflare-r2-binding\",\n  fs: \"unstorage/drivers/fs\",\n  fsLite: \"unstorage/drivers/fs-lite\",\n  github: \"unstorage/drivers/github\",\n  http: \"unstorage/drivers/http\",\n  indexedb: \"unstorage/drivers/indexedb\",\n  localStorage: \"unstorage/drivers/localstorage\",\n  lruCache: \"unstorage/drivers/lru-cache\",\n  memory: \"unstorage/drivers/memory\",\n  mongodb: \"unstorage/drivers/mongodb\",\n  netlifyBlobs: \"unstorage/drivers/netlify-blobs\",\n  overlay: \"unstorage/drivers/overlay\",\n  planetscale: \"unstorage/drivers/planetscale\",\n  redis: \"unstorage/drivers/redis\",\n  sessionStorage: \"unstorage/drivers/session-storage\",\n  vercelKV: \"unstorage/drivers/vercel-kv\",\n  /** @deprecated */\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  /** @deprecated */\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\"\n};\n\nexport { builtinDrivers, createStorage, defineDriver, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}